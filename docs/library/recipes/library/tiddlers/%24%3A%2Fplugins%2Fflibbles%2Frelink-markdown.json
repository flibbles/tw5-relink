{"name":"Relink Markdown","title":"$:/plugins/flibbles/relink-markdown","description":"Markdown support for Relink","author":"Flibbles","version":"1.10.0","core-version":">=5.1.14","parent-plugin":"$:/plugins/flibbles/relink","source":"https://github.com/flibbles/tw5-relink","list":"readme","dependents":"","plugin-type":"plugin","type":"application/json","text":"{\n    \"tiddlers\": {\n        \"$:/plugins/flibbles/relink/js/fieldtypes/markdown.js\": {\n            \"title\": \"$:/plugins/flibbles/relink/js/fieldtypes/markdown.js\",\n            \"text\": \"/*\\\\\\nmodule-type: relinkfieldtype\\ntitle: $:/plugins/flibbles/relink/js/fieldtypes/markdown.js\\ntype: application/javascript\\n\\nThis relinks tiddlers which contain markdown. It tries to be agnostic to\\nwhichever markdown plugin you're using.\\n\\n\\\\*/\\n\\nvar EntryNode = require('$:/plugins/flibbles/relink/js/utils/entry');\\nvar Rebuilder = require(\\\"$:/plugins/flibbles/relink/js/utils/rebuilder.js\\\");\\nvar utils = require(\\\"$:/plugins/flibbles/relink/js/utils/markdown.js\\\");\\nvar WikiParser = require(\\\"$:/core/modules/parsers/wikiparser/wikiparser.js\\\")['text/vnd.tiddlywiki'];\\n\\nvar MarkdownEntry = EntryNode.newType(\\\"markdown\\\");\\n\\nfunction MarkdownRelinker(text, fromTitle, toTitle, options) {\\n\\tthis.wiki = options.wiki;\\n\\tthis.entry = new MarkdownEntry();\\n\\tthis.builder = new Rebuilder(text);\\n\\tthis.fromTitle = fromTitle;\\n\\tthis.toTitle = toTitle;\\n\\tthis.options = options;\\n\\tif(!this.mdInlineRuleClasses) {\\n\\t\\tMarkdownRelinker.prototype.mdInlineRuleClasses = $tw.modules.createClassesFromModules(\\\"relinkmarkdownrule\\\",\\\"inline\\\",$tw.MarkdownRuleBase);\\n\\t}\\n\\tif(!this.mdBlockRuleClasses) {\\n\\t\\tMarkdownRelinker.prototype.mdBlockRuleClasses = $tw.modules.createClassesFromModules(\\\"relinkmarkdownrule\\\",\\\"block\\\",$tw.MarkdownRuleBase);\\n\\t}\\n\\tthis.source = text || \\\"\\\";\\n\\tthis.sourceLength = this.source.length;\\n\\t// Set current parse position\\n\\tthis.pos = 0;\\n\\t// Instantiate the parser block and inline rules\\n\\tthis.blockRules = this.instantiateRules(this.mdBlockRuleClasses,\\\"block\\\",0);\\n\\tthis.inlineRules = this.instantiateRules(this.mdInlineRuleClasses,\\\"inline\\\",0);\\n\\t// instantiateRules first with indent==undefined so we can match regardless\\n\\t// of tabdepth. Now we need to be strict about it.\\n\\tthis.indent = 0;\\n\\tthis.parseBlocks();\\n};\\n\\nMarkdownRelinker.prototype = Object.create(WikiParser.prototype);\\n\\nmodule.exports\\n\\nMarkdownRelinker.prototype.parseBlock = function(terminatorRegExpString) {\\n\\tvar terminatorRegExp = /([^\\\\S\\\\n]*\\\\r?\\\\n)/mg;\\n\\tthis.skipEmptyLines();\\n\\tif(this.pos >= this.sourceLength) {\\n\\t\\treturn [];\\n\\t}\\n\\t// Look for a block rule that applies at the current position\\n\\tvar nextMatch = this.findNextMatch(this.blockRules, this.pos);\\n\\tif(nextMatch && nextMatch.matchIndex === this.pos) {\\n\\t\\treturn this.relinkRule(nextMatch);\\n\\t}\\n\\treturn this.parseInlineRun(terminatorRegExp);\\n};\\n\\nMarkdownRelinker.prototype.relinkRule = function(ruleInfo) {\\n\\tvar newEntry = ruleInfo.rule.relink(this.source, this.fromTitle, this.toTitle, this.options);\\n\\tif (newEntry !== undefined) {\\n\\t\\tthis.entry.add(newEntry);\\n\\t\\tif (newEntry.output) {\\n\\t\\t\\tthis.builder.add(newEntry.output, ruleInfo.matchIndex, this.pos);\\n\\t\\t}\\n\\t}\\n};\\n\\nMarkdownRelinker.prototype.parseInlineRunTerminated = function(terminatorRegExp,options) {\\n\\toptions = options || {};\\n\\tvar tree = [];\\n\\t// Find the next occurrence of the terminator\\n\\tterminatorRegExp.lastIndex = this.pos;\\n\\tvar terminatorMatch = terminatorRegExp.exec(this.source);\\n\\t// Find the next occurrence of a inlinerule\\n\\tvar inlineRuleMatch = this.findNextMatch(this.inlineRules,this.pos);\\n\\t// Loop around until we've reached the end of the text\\n\\twhile(this.pos < this.sourceLength && (terminatorMatch || inlineRuleMatch)) {\\n\\t\\t// Return if we've found the terminator, and it precedes any inline rule match\\n\\t\\tif(terminatorMatch) {\\n\\t\\t\\tif(!inlineRuleMatch || inlineRuleMatch.matchIndex >= terminatorMatch.index) {\\n\\t\\t\\t\\tthis.relinkWikitext(this.pos, terminatorMatch.index);\\n\\t\\t\\t\\t//if(options.eatTerminator) {\\n\\t\\t\\t\\t\\tthis.pos += terminatorMatch[0].length;\\n\\t\\t\\t\\t//}\\n\\t\\t\\t\\treturn tree;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Process any inline rule, along with the text preceding it\\n\\t\\tif(inlineRuleMatch) {\\n\\t\\t\\t// Preceding text\\n\\t\\t\\tthis.relinkWikitext(this.pos, inlineRuleMatch.matchIndex);\\n\\t\\t\\tthis.relinkRule(inlineRuleMatch);\\n\\t\\t\\t// Look for the next inline rule\\n\\t\\t\\tinlineRuleMatch = this.findNextMatch(this.inlineRules,this.pos);\\n\\t\\t\\t// Look for the next terminator match\\n\\t\\t\\tterminatorRegExp.lastIndex = this.pos;\\n\\t\\t\\tterminatorMatch = terminatorRegExp.exec(this.source);\\n\\t\\t}\\n\\t}\\n\\t// Process the remaining text\\n\\tthis.relinkWikitext(this.pos, this.sourceLength);\\n\\treturn tree;\\n};\\n\\nMarkdownRelinker.prototype.skipEmptyLines = function() {\\n\\tvar emptyRegExp = /(?:[^\\\\S\\\\n]*\\\\n)+/mg;\\n\\temptyRegExp.lastIndex = this.pos;\\n\\tvar emptyMatch = emptyRegExp.exec(this.source);\\n\\tif(emptyMatch && emptyMatch.index === this.pos) {\\n\\t\\tthis.pos = emptyRegExp.lastIndex;\\n\\t}\\n};\\n\\nMarkdownRelinker.prototype.relinkWikitext = function(startPos, end) {\\n\\tif (startPos < end) {\\n\\t\\tvar config = utils.getSettings(this.wiki);\\n\\t\\tif (config.wikitext) {\\n\\t\\t\\tvar substr = this.source.substring(this.pos, end);\\n\\n\\t\\t\\tvar pragma = config.wikitextPragma;\\n\\t\\t\\tvar wikitextHandler = this.options.settings.getType('wikitext');\\n\\t\\t\\tvar wikiEntry = wikitextHandler.relink(pragma + substr, this.fromTitle, this.toTitle, this.options);\\n\\t\\t\\tif (wikiEntry != undefined) {\\n\\t\\t\\t\\tthis.entry.add(wikiEntry);\\n\\t\\t\\t\\tif (wikiEntry.output) {\\n\\t\\t\\t\\t\\tthis.builder.add(wikiEntry.output.slice(pragma.length), startPos, end);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tthis.pos = end;\\n}\\n\\nexports.name = \\\"markdown\\\";\\n\\nexports.relink = function(markdowntext, fromTitle, toTitle, options) {\\n\\tvar relinker = new MarkdownRelinker(markdowntext, fromTitle, toTitle, options);\\n\\tvar entry = relinker.entry;\\n\\tif (entry.children.length > 0) {\\n\\t\\tentry.output = relinker.builder.results();\\n\\t\\treturn entry;\\n\\t}\\n\\treturn undefined;\\n};\\n\",\n            \"module-type\": \"relinkfieldtype\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeblock.js\": {\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeblock.js\",\n            \"text\": \"/*\\\\\\nmodule-type: relinkmarkdownrule\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeblock.js\\ntype: application/javascript\\n\\n```javascript\\ncode\\n```\\n\\n\\\\*/\\n\\nvar utils = require(\\\"$:/plugins/flibbles/relink/js/utils/markdown\\\");\\n\\nexports.name = \\\"codeblock\\\";\\nexports.types = {inline: true};\\n\\nexports.init = function(parser) {\\n\\tthis.parser = parser;\\n\\tthis.matchRegExp = /(```+)[^\\\\n`]*(?:\\\\n|$)/mg;\\n\\tthis.maxIndent = 3;\\n};\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tvar endRegExp = new RegExp(\\\"^ {0,3}\\\" + this.match[1] + \\\"+[^\\\\\\\\S\\\\\\\\n]*\\\\\\\\n\\\", \\\"mg\\\");\\n\\tendRegExp.lastIndex = this.matchRegExp.lastIndex;\\n\\tvar endMatch = endRegExp.exec(this.parser.source);\\n\\tif (endMatch) {\\n\\t\\tthis.parser.pos = endRegExp.lastIndex;\\n\\t} else {\\n\\t\\tthis.parser.pos = this.parser.sourceLength;\\n\\t}\\n\\treturn undefined;\\n};\\n\",\n            \"module-type\": \"relinkmarkdownrule\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeinline.js\": {\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeinline.js\",\n            \"text\": \"/*\\\\\\nmodule-type: relinkmarkdownrule\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeinline.js\\ntype: application/javascript\\n\\nHandles markdown `code` and ``code``.\\n\\n\\\\*/\\n\\nvar utils = require(\\\"$:/plugins/flibbles/relink/js/utils/markdown\\\");\\n\\nexports.name = \\\"codeinline\\\";\\nexports.types = {inline: true};\\n\\nexports.init = function(parser) {\\n\\tthis.parser = parser;\\n};\\n\\nexports.findNextMatch = function(startPos) {\\n\\tvar match, matchRegExp = /`+/mg;\\n\\tmatchRegExp.lastIndex = startPos;\\n\\twhile (match = matchRegExp.exec(this.parser.source)) {\\n\\t\\tvar next = this.parser.source.indexOf(match[0], matchRegExp.lastIndex);\\n\\t\\t// make sure we find the corresponding ticks\\n\\t\\tif (next >= 0) {\\n\\t\\t\\t// Make sure it's the right length\\n\\t\\t\\tvar end = next + match[0].length;\\n\\t\\t\\tif (match[0].length < 3 || !isLineStart(this.parser.source, next)) {\\n\\t\\t\\t\\tif (this.parser.source.charAt(end) !== '`') {\\n\\t\\t\\t\\t\\t// make sure there aren't paragraph breaks between the points\\n\\t\\t\\t\\t\\tvar nextGraph = utils.indexOfParagraph(this.parser.source, matchRegExp.lastIndex);\\n\\t\\t\\t\\t\\tif (nextGraph < 0 || nextGraph > next) {\\n\\t\\t\\t\\t\\t\\tthis.end = end;\\n\\t\\t\\t\\t\\t\\treturn match.index;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn undefined;\\n};\\n\\nfunction isLineStart(text, pos) {\\n\\t// if 3 or less spaces precede it, it's a line start.\\n\\tvar p = text.lastIndexOf('\\\\n', pos);\\n\\tif (pos - p > 3) {\\n\\t\\treturn false;\\n\\t}\\n\\twhile (++p < pos) {\\n\\t\\tif (text.charAt(p) !== ' ') {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n};\\n\\nexports.relink = function() {\\n\\tthis.parser.pos = this.end;\\n\\treturn undefined;\\n};\\n\",\n            \"module-type\": \"relinkmarkdownrule\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/footnote.js\": {\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/footnote.js\",\n            \"text\": \"/*\\\\\\nmodule-type: relinkmarkdownrule\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/footnote.js\\ntype: application/javascript\\n\\nHandles markdown footnotes\\n\\n[1]: #link\\n\\n\\\\*/\\n\\nvar utils = require(\\\"$:/plugins/flibbles/relink/js/utils/markdown\\\");\\n\\nfunction FootnoteEntry() {};\\nFootnoteEntry.prototype.name = \\\"markdownfootnote\\\";\\nFootnoteEntry.prototype.report = function() {\\n\\treturn [\\\"[\\\" + utils.abridge(this.caption) + \\\"]:\\\"];\\n};\\n\\nexports.name = \\\"markdownfootnote\\\";\\nexports.types = {block: true};\\n\\nexports.init = function(parser) {\\n\\tthis.parser = parser;\\n\\tthis.matchRegExp = /\\\\[((?:[^\\\\\\\\\\\\]]|\\\\\\\\.)*)\\\\]:(\\\\s*)(#?)(\\\\S+)([^\\\\S\\\\n]*(?:\\\\n|$))/mg;\\n\\tthis.maxIndent = 3;\\n};\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tvar m = this.match,\\n\\t\\tlink = m[4],\\n\\t\\tentry;\\n\\tthis.parser.pos = m.index + m[0].length;\\n\\tif (m[1].charAt(0) !== \\\"^\\\"\\n\\t && (m[3] === \\\"#\\\" || options.wiki.isImageTiddler(toTitle))\\n\\t && decodeURIComponent(link) === fromTitle) {\\n\\t\\tentry = new FootnoteEntry();\\n\\t\\tentry.caption = m[1];\\n\\t\\tentry.output = this.indentString + \\\"[\\\" + m[1] + \\\"]:\\\" + m[2] + m[3] + utils.encodeLink(toTitle) + m[5];\\n\\t}\\n\\treturn entry;\\n};\\n\",\n            \"module-type\": \"relinkmarkdownrule\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/link.js\": {\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/link.js\",\n            \"text\": \"/*\\\\\\nmodule-type: relinkmarkdownrule\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/link.js\\ntype: application/javascript\\n\\nHandles markdown links\\n\\n[caption](#link)\\n\\n\\\\*/\\n\\nvar utils = require(\\\"$:/plugins/flibbles/relink/js/utils/markdown\\\");\\nvar settings = require(\\\"$:/plugins/flibbles/relink/js/settings\\\");\\nvar markdown = settings.getType('markdown');\\n\\nfunction LinkEntry() {};\\nLinkEntry.prototype.name = \\\"markdownlink\\\";\\nLinkEntry.prototype.report = function() {\\n\\tvar output = [];\\n\\tvar hash = '#';\\n\\tif (this.prefix) {\\n\\t\\thash = '';\\n\\t}\\n\\tif (this.captionEntry) {\\n\\t\\tvar self = this;\\n\\t\\t$tw.utils.each(this.captionEntry.report(), function(report) {\\n\\t\\t\\toutput.push(self.prefix+\\\"[\\\" + (report || '') + \\\"](\\\" + hash + self.link + \\\")\\\");\\n\\t\\t});\\n\\t};\\n\\tif (this.linkChanged) {\\n\\t\\tvar safeCaption = utils.abridge(this.caption);\\n\\t\\toutput.push(this.prefix+\\\"[\\\" + safeCaption + \\\"](\\\" + hash + \\\")\\\");\\n\\t}\\n\\treturn output;\\n};\\n\\nLinkEntry.prototype.eachChild = function(method) {\\n\\tif (this.captionEntry) {\\n\\t\\tmethod(this.captionEntry);\\n\\t}\\n};\\n\\nexports.name = \\\"markdownlink\\\";\\nexports.types = {inline: true};\\n\\nexports.init = function(parser) {\\n\\tthis.parser = parser;\\n};\\n\\nexports.findNextMatch = function(startPos) {\\n\\tthis.endMatch = this.matchLink(this.parser.source, startPos);\\n\\treturn this.endMatch ? this.endMatch.index : undefined;\\n};\\n\\nexports.survey = function(text) {\\n\\treturn this.matchLink(text, 0);\\n};\\n\\n/**A zero side-effect method which returns a regexp which pretended to match\\n * the whole link, caption and all. I do this instead of just using a\\n * regexp to begin with, because markdown links require context-free grammar\\n * matching.\\n * Currently, it doesn't properly set match[0]. No need as of yet.\\n * 1. \\\"!\\\"\\n * 2. caption\\n * 3. \\\"\\\\s*#?\\\"\\n * 4. \\\"link\\\"\\n * 5. \\\"\\\\s*'tooltip'\\\"\\n */\\nexports.matchLink = function(text, pos) {\\n\\tpos = pos-1;\\n\\tvar match = undefined;\\n\\tdo {\\n\\t\\tpos = text.indexOf('[', pos+1);\\n\\t\\tif (pos < 0) {\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\t\\tvar caption = this.getEnclosed(text, pos, '[', ']');\\n\\t\\tif (caption === undefined) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tvar linkStart = pos + caption.length+2;\\n\\t\\tif (text.charAt(linkStart) !== '(') {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t// match[1] and match[2] are the \\\"!\\\" and \\\"caption\\\", filled in later.\\n\\t\\tvar regExp = /\\\\(()()(\\\\s*#?)((?:[^\\\\s\\\\(\\\\)]|\\\\([^\\\\s\\\\(\\\\)]*\\\\))+)((?:\\\\s+(?:'(?:[^'\\\\\\\\]|\\\\\\\\.)*'|\\\"(?:[^\\\"\\\\\\\\]|\\\\\\\\.)*\\\"|\\\\([^)]*\\\\)))?\\\\s*)\\\\)/g;\\n\\t\\tregExp.lastIndex = linkStart;\\n\\t\\tmatch = regExp.exec(text);\\n\\t\\tif (match && match.index === linkStart && utils.indexOfParagraph(match[0]) < 0) {\\n\\t\\t\\tmatch[2] = caption;\\n\\t\\t\\tif (text.charAt(pos-1) === \\\"!\\\") {\\n\\t\\t\\t\\tmatch.index = pos-1;\\n\\t\\t\\t\\tmatch[1] = \\\"!\\\";\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmatch.index = pos;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tmatch = undefined;\\n\\t\\t}\\n\\t} while (!match);\\n\\treturn match;\\n};\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tvar entry = new LinkEntry(),\\n\\t\\tem = this.endMatch,\\n\\t\\tmodified = false,\\n\\t\\tcaption = em[2],\\n\\t\\timage = (em[1] === '!'),\\n\\t\\tlink = em[4];\\n\\tthis.parser.pos = em.index + em[1].length + caption.length + em[0].length + 2;\\n\\tif (!image) {\\n\\t\\tvar newCaption = markdown.relink(caption, fromTitle, toTitle, options);\\n\\t\\tif (newCaption) {\\n\\t\\t\\tmodified = true;\\n\\t\\t\\tentry.captionEntry = newCaption;\\n\\t\\t\\tif (newCaption.output) {\\n\\t\\t\\t\\tif (this.canBeCaption(newCaption.output)) {\\n\\t\\t\\t\\t\\tcaption = newCaption.output;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnewCaption.impossible = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// I don't know why internal images links don't use the '#', but links\\n\\t// do, but that's just how it is.\\n\\tif (image !== (em[3].lastIndexOf('#') >=0)) {\\n\\t\\ttry {\\n\\t\\t\\tif (decodeURIComponent(link) === fromTitle) {\\n\\t\\t\\t\\tmodified = true;\\n\\t\\t\\t\\tentry.linkChanged = true;\\n\\t\\t\\t\\tlink = utils.encodeLink(toTitle);\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t// It must be a malformed link. Not our problem.\\n\\t\\t\\t// Keep going in case the caption needs relinking.\\n\\t\\t}\\n\\t}\\n\\tif (modified) {\\n\\t\\tentry.link = link;\\n\\t\\tentry.caption = caption;\\n\\t\\tentry.prefix = em[1];\\n\\t\\t// This way preserves whitespace\\n\\t\\tentry.output = em[1]+\\\"[\\\"+caption+\\\"](\\\"+em[3]+link+em[5]+\\\")\\\";\\n\\t\\treturn entry;\\n\\t}\\n\\treturn undefined;\\n};\\n\\nexports.canBeCaption = function(caption) {\\n\\treturn this.indexOfClose(caption+']', -1, '[', ']') === caption.length;\\n};\\n\\nexports.getEnclosed = function(text, pos, openChar, closeChar) {\\n\\tvar capEnd = this.indexOfClose(text, pos, openChar, closeChar);\\n\\tif (capEnd < 0) {\\n\\t\\treturn undefined;\\n\\t}\\n\\tvar enclosed = text.substring(pos+1, capEnd);\\n\\tif (enclosed.match(/\\\\n\\\\s*\\\\n/)) {\\n\\t\\t// Paragraph breaks are not allowed\\n\\t\\treturn undefined;\\n\\t}\\n\\treturn enclosed;\\n};\\n\\nexports.indexOfClose = function(text, pos, openChar, closeChar) {\\n\\tvar close = pos-1,\\n\\t\\topen = pos; // First char is open\\n\\tdo {\\n\\t\\tclose = text.indexOf(closeChar, close+1);\\n\\t\\tif (close < 0) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\topen = text.indexOf(openChar, open+1);\\n\\t} while (open >= 0 && open <= close);\\n\\treturn close;\\n};\\n\",\n            \"module-type\": \"relinkmarkdownrule\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/markdownrulebase.js\": {\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/markdownrulebase.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/markdownrulebase.js\\ntype: application/javascript\\nmodule-type: global\\n\\nBase class for markdown parser rules\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar utils = require(\\\"$:/plugins/flibbles/relink/js/utils/markdown\\\");\\n\\nvar MarkdownRuleBase = function() {};\\n\\nMarkdownRuleBase.prototype.init = function(parser) {\\n\\tthis.parser = parser;\\n};\\n\\nMarkdownRuleBase.prototype.findNextMatch = function(startPos) {\\n\\tthis.matchRegExp.lastIndex = startPos;\\n\\twhile (this.match = this.matchRegExp.exec(this.parser.source)) {\\n\\t\\tif (utils.indexOfParagraph(this.match[0]) >= 0) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (this.maxIndent !== undefined) {\\n\\t\\t\\tvar indent = utils.indentation(this.parser.source,this.match.index);\\n\\t\\t\\tif (indent < 0\\n\\t\\t\\t || (this.parser.indent !== undefined\\n\\t\\t\\t  && (indent > this.parser.indent + this.maxIndent))) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tvar nl = this.parser.source.lastIndexOf('\\\\n', this.match.index-1)+1;\\n\\t\\t\\tthis.indentString = this.parser.source.substring(nl, this.match.index);\\n\\t\\t\\treturn nl < startPos ? startPos : nl;\\n\\t\\t}\\n\\t\\treturn this.match.index;\\n\\t}\\n\\treturn undefined;\\n};\\n\\n\\nexports.MarkdownRuleBase = MarkdownRuleBase;\\n\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"global\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext.js\": {\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext.js\",\n            \"text\": \"/*\\\\\\nmodule-type: relinktextoperator\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext.js\\ntype: application/javascript\\n\\nThis relinks tiddlers which contain markdown. It tries to be agnostic to\\nwhichever markdown plugin you're using.\\n\\n\\\\*/\\n\\n/*jslint node: false, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar Placeholder = require(\\\"$:/plugins/flibbles/relink/js/utils/placeholder.js\\\");\\nvar settings = require('$:/plugins/flibbles/relink/js/settings.js');\\nvar markdownHandler = settings.getType('markdown');\\n\\nexports[\\\"text/x-markdown\\\"] = function(tiddler, fromTitle, toTitle, options) {\\n\\tvar placeholder = new Placeholder();\\n\\tvar extraOptions = $tw.utils.extend(\\n\\t\\t{\\n\\t\\t\\tcurrentTiddler: tiddler.fields.title,\\n\\t\\t\\tplaceholder: placeholder\\n\\t\\t}, options);\\n\\tvar entry = markdownHandler.relink(tiddler.fields.text, fromTitle, toTitle, extraOptions);\\n\\tif (entry && entry.output) {\\n\\t\\t// If there's output, we've also got to prepend any macros\\n\\t\\t// that the placeholder defined.\\n\\t\\tvar preamble = placeholder.getPreamble();\\n\\t\\tentry.output = preamble + entry.output\\n\\t}\\n\\treturn entry;\\n};\\n\\n\",\n            \"module-type\": \"relinktextoperator\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/utils/markdown.js\": {\n            \"title\": \"$:/plugins/flibbles/relink/js/utils/markdown.js\",\n            \"text\": \"/*\\\\\\nmodule-type: library\\ntitle: $:/plugins/flibbles/relink/js/utils/markdown.js\\ntype: application/javascript\\n\\nMethods used in markdown parsing.\\n\\n\\\\*/\\n\\n// tiddlywiki/markdown can't handle having these characters escaped, so we\\n// need to unescape them.\\nvar problemChars = {\\n\\t\\\"23\\\": \\\"#\\\",\\n\\t\\\"24\\\": \\\"$\\\",\\n\\t\\\"26\\\": \\\"&\\\",\\n\\t\\\"2B\\\": \\\"+\\\",\\n\\t\\\"2C\\\": \\\",\\\",\\n\\t\\\"2F\\\": \\\"/\\\",\\n\\t\\\"3A\\\": \\\":\\\",\\n\\t\\\"3B\\\": \\\";\\\",\\n\\t\\\"3D\\\": \\\"=\\\",\\n\\t\\\"3F\\\": \\\"?\\\",\\n\\t\\\"40\\\": \\\"@\\\",\\n};\\n\\nexports.encodeLink = function(title) {\\n\\tvar encoded = encodeURIComponent(title),\\n\\t\\tbalance = 0;\\n\\tencoded = encoded.replace(/[\\\\(\\\\)]/g, function(p) {\\n\\t\\tif (p === '(') {\\n\\t\\t\\tif (balance >=1) {\\n\\t\\t\\t\\treturn '%28';\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbalance++;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif (balance <= 0) {\\n\\t\\t\\t\\treturn '%29';\\n\\t\\t\\t}\\n\\t\\t\\tbalance--;\\n\\t\\t}\\n\\t\\treturn p;\\n\\t});\\n\\twhile (balance--) {\\n\\t\\tvar i = encoded.lastIndexOf('(');\\n\\t\\tencoded = encoded.substr(0, i) + '%28' + encoded.substr(i+1);\\n\\t}\\n\\t// tiddlywiki/markdown can't handle these characters escaped\\n\\treturn encoded.replace(/%([0-9A-F]{2})/g, function(str, code) {\\n\\t\\treturn problemChars[code] || str;\\n\\t});\\n};\\n\\n// Returns index of next paragraph, or -1\\nexports.indexOfParagraph = function(text, startPos) {\\n\\tvar regExp = /\\\\n\\\\s*\\\\n/mg;\\n\\tregExp.lastIndex = startPos || 0;\\n\\tvar match = regExp.exec(text);\\n\\treturn match ? regExp.lastIndex : -1;\\n};\\n\\n/** Returns how much indentation there is between pos and the previous\\n * newline (or other char).\\n * tabs are counted as 4 chars.\\n */\\nexports.indentation = function(text, pos, startChar) {\\n\\tvar p = text.lastIndexOf(startChar || '\\\\n', pos-1);\\n\\tvar count = 0;\\n\\twhile (++p < pos) {\\n\\t\\tvar c = text.charAt(p);\\n\\t\\tif (c === ' ') {\\n\\t\\t\\tcount++;\\n\\t\\t} else if (c === '\\\\t') {\\n\\t\\t\\tcount = count + 4 - (count%4);\\n\\t\\t} else {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n};\\n\\n\\nexports.getSettings = function(wiki) {\\n\\t// Stored here so it's only calculated once, but also so it's different\\n\\t// per tiddler for testing\\n\\tif (wiki._markdownSettings === undefined) {\\n\\t\\tvar settings = Object.create(null);\\n\\t\\tvar text = wiki.getTiddlerText(\\\"$:/config/markdown/renderWikiText\\\");\\n\\t\\tsettings.wikitext =  (text === undefined || text.toLowerCase() === \\\"true\\\");\\n\\t\\ttext = wiki.getTiddlerText(\\\"$:/config/markdown/renderWikiTextPragma\\\");\\n\\t\\tif (text) {\\n\\t\\t\\ttext = text.trim() + '\\\\n';\\n\\t\\t} else {\\n\\t\\t\\ttext = '';\\n\\t\\t}\\n\\t\\tsettings.wikitextPragma = text;\\n\\t\\twiki._markdownSettings = settings;\\n\\t}\\n\\treturn wiki._markdownSettings;\\n};\\n\\n// This is the maximum length a reported caption may be\\nexports.captionLength = 15;\\n\\n/** Abridges a string to one that is more log-friendly.\\n */\\nexports.abridge = function(string) {\\n\\tvar safe = string.replace(/\\\\s+/mg, ' ');\\n\\tif (safe.length > this.captionLength) {\\n\\t\\tsafe = safe.substr(0, this.captionLength) + \\\"...\\\";\\n\\t}\\n\\treturn safe;\\n};\\n\\n/**I don't actually use this, but I've kept the code around anyway.\\n * The only time this plugin is installed and markdown isn't enabled would\\n * be if the user forgot to install a markdown plugin, or they disabled it.\\n * I GUESS Relink should still be Relinking markdown in that case.\\n */\\nexports.markdownEnabled = function() {\\n\\tif (_enabled === undefined) {\\n\\t\\tvar test = $tw.wiki.renderText(\\\"text/html\\\", \\\"text/x-markdown\\\", \\\"[test](#test)\\\");\\n\\t\\t_enabled = (test.indexOf(\\\"<a\\\") >= 0);\\n\\t}\\n\\treturn _enabled;\\n};\\nvar _enabled;\\n\",\n            \"module-type\": \"library\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink-markdown/readme\": {\n            \"title\": \"$:/plugins/flibbles/relink-markdown/readme\",\n            \"text\": \"Markdown support for Relink.\\n\\n...or Relink support for Markdown.\\n\\nThis supplimental plugin allows ''text/x-markdown'' files to be relinked. This means markdown linking syntax like `[Caption](#MyTiddler)` is supported. If your markdown supports wikitext markup as well, this will handle that too.\\n\\nThis plugin is designed for `tiddlywiki/markdown`, but it will also work for `anstosa/tw5-markdown` and others.\\n\"\n        }\n    }\n}"}