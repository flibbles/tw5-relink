{"name":"Relink","title":"$:/plugins/flibbles/relink","description":"Flexibility when relinking renamed tiddlers","author":"Flibbles","version":"1.10.0","core-version":">=5.1.14","source":"https://github.com/flibbles/tw5-relink","demo":"http://flibbles.github.io/tw5-relink/","list":"readme configuration","dependents":"","plugin-type":"plugin","type":"application/json","text":"{\n    \"tiddlers\": {\n        \"$:/plugins/flibbles/relink/js/bulkops.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: startup\\n\\nReplaces the relinkTiddler defined in $:/core/modules/wiki-bulkops.js\\n\\nThis is a startup instead of a wikimethods module-type because it's the only\\nway to ensure this runs after the old relinkTiddler method is applied.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: false, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar language = require('$:/plugins/flibbles/relink/js/language.js');\\n\\nexports.name = \\\"redefine-relinkTiddler\\\";\\nexports.synchronous = true;\\n// load-modules is when wikimethods are applied in\\n// ``$:/core/modules/startup/load-modules.js``\\nexports.after = ['load-modules'];\\n\\nexports.startup = function() {\\n\\t$tw.Wiki.prototype.relinkTiddler = relinkTiddler;\\n};\\n\\n/** Walks through all relinkable tiddlers and relinks them.\\n *  This replaces the existing function in core Tiddlywiki.\\n */\\nfunction relinkTiddler(fromTitle, toTitle, options) {\\n\\tvar self = this;\\n\\tvar failures = [];\\n\\tvar records = this.getRelinkReport(fromTitle, toTitle, options);\\n\\tfor (var title in records) {\\n\\t\\tvar entries = records[title];\\n\\t\\tvar changes = Object.create(null);\\n\\t\\tvar update = false;\\n\\t\\tfor (var field in entries) {\\n\\t\\t\\tvar entry = entries[field];\\n\\t\\t\\tlanguage.eachImpossible(entry, function() {\\n\\t\\t\\t\\tfailures.push(title);\\n\\t\\t\\t});\\n\\t\\t\\tlanguage.logAll(entry, title, fromTitle, toTitle, options);\\n\\t\\t\\tif (entry && entry.output) {\\n\\t\\t\\t\\tchanges[field] = entry.output;\\n\\t\\t\\t\\tupdate = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// If any fields changed, update tiddler\\n\\t\\tif (update) {\\n\\t\\t\\tvar tiddler = this.getTiddler(title);\\n\\t\\t\\tvar newTiddler = new $tw.Tiddler(tiddler,changes,self.getModificationFields())\\n\\t\\t\\tnewTiddler = $tw.hooks.invokeHook(\\\"th-relinking-tiddler\\\",newTiddler,tiddler);\\n\\t\\t\\tself.addTiddler(newTiddler);\\n\\t\\t}\\n\\t};\\n\\tif (failures.length > 0) {\\n\\t\\tvar options = $tw.utils.extend(\\n\\t\\t\\t{ variables: {to: toTitle, from: fromTitle},\\n\\t\\t\\t  wiki: this},\\n\\t\\t\\toptions );\\n\\t\\tlanguage.reportFailures(failures, options);\\n\\t}\\n};\\n\\n})();\\n\",\n            \"module-type\": \"startup\",\n            \"title\": \"$:/plugins/flibbles/relink/js/bulkops.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/language.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: library\\n\\nThis handles all logging and alerts Relink emits.\\n\\n\\\\*/\\n\\nvar prettylink = require(\\\"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/prettylink.js\\\");\\nvar Placeholder = require(\\\"$:/plugins/flibbles/relink/js/utils/placeholder.js\\\");\\n\\nexports.eachImpossible = function(rootEntry, method) {\\n\\tif (rootEntry.eachChild) {\\n\\t\\trootEntry.eachChild(function(child) {\\n\\t\\t\\texports.eachImpossible.call(this, child, method);\\n\\t\\t});\\n\\t}\\n\\tif (rootEntry.impossible) {\\n\\t\\tmethod(rootEntry);\\n\\t}\\n};\\n\\nexports.logAll = function(entry, title, from, to, options) {\\n\\tvar raw = exports.log[entry.name];\\n\\tif (entry.impossible) {\\n\\t\\treturn;\\n\\t}\\n\\tif (raw) {\\n\\t\\texports.logRelink(raw, entry, title, from, to, options);\\n\\t\\treturn;\\n\\t}\\n\\tif (entry.eachChild) {\\n\\t\\tentry.eachChild(function(child) {\\n\\t\\t\\texports.logAll(child, title, from, to, options);\\n\\t\\t});\\n\\t}\\n};\\n\\nexports.logRelink = function(raw, args, title, from, to, options) {\\n\\traw = \\\"Renaming '\\\"+from+\\\"' to '\\\"+to+\\\"' in \\\" + raw + \\\" of tiddler '\\\"+title+\\\"'\\\";\\n\\t// This is cheap, but whatevs. To do a proper\\n\\t// rendering would require working through a wiki\\n\\t// object. Too heavy weight for log messages.\\n\\tvar msg = raw.replace(/<<([^<>]+)>>/g, function(match, key) {\\n\\t\\tvar value = args[key];\\n\\t\\tif (key === \\\"field\\\") {\\n\\t\\t\\tvalue = descriptor(value);\\n\\t\\t};\\n\\t\\treturn value || (\\\"<<\\\"+key+\\\">>\\\");\\n\\t});\\n\\tconsole.log(msg);\\n};\\n\\n// This wraps alert so it can be monkeypatched during testing.\\nexports.alert = function(message) {\\n\\talert(message);\\n};\\n\\nexports.getString = function(title, options) {\\n\\ttitle = \\\"$:/plugins/flibbles/relink/language/\\\" + title;\\n\\treturn options.wiki.renderTiddler(\\\"text/plain\\\", title, options);\\n};\\n\\nvar logger;\\n\\nexports.reportFailures = function(failureList, options) {\\n\\tif (!logger) {\\n\\t\\tlogger = new $tw.utils.Logger(\\\"Relinker\\\");\\n\\t}\\n\\tvar alertString = this.getString(\\\"Error/ReportFailedRelinks\\\", options)\\n\\tvar placeholder = new Placeholder(options);\\n\\tvar phOptions = $tw.utils.extend({placeholder: placeholder}, options);\\n\\tvar alreadyReported = Object.create(null);\\n\\tvar reportList = [];\\n\\t$tw.utils.each(failureList, function(f) {\\n\\t\\tif (!alreadyReported[f]) {\\n\\t\\t\\tif ($tw.browser) {\\n\\t\\t\\t\\treportList.push(\\\"\\\\n* \\\" + prettylink.makeLink(f, undefined, phOptions));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treportList.push(\\\"\\\\n* \\\" + f);\\n\\t\\t\\t}\\n\\t\\t\\talreadyReported[f] = true;\\n\\t\\t}\\n\\t});\\n\\tlogger.alert(placeholder.getPreamble() + alertString + \\\"\\\\n\\\" + reportList.join(\\\"\\\"));\\n};\\n\\nexports.log = {\\n\\t\\\"html\\\": \\\"<<<element>> /> element\\\",\\n\\t\\\"field\\\": \\\"<<field>>\\\",\\n\\t\\\"filteredtransclude\\\": \\\"filtered transclusion\\\",\\n\\t\\\"image\\\": \\\"image\\\",\\n\\t\\\"import\\\": \\\"\\\\\\\\import filter\\\",\\n\\t\\\"macrodef\\\": \\\"<<macro>> definition\\\",\\n\\t\\\"prettylink\\\": \\\"prettylink\\\",\\n\\t\\\"syslink\\\": \\\"syslink\\\",\\n\\t\\\"transclude\\\": \\\"transclusion\\\",\\n\\t\\\"wikilink\\\": \\\"CamelCase link\\\",\\n};\\n\\nfunction descriptor(field) {\\n\\tif (field === \\\"tags\\\") {\\n\\t\\treturn \\\"tags\\\";\\n\\t} else {\\n\\t\\treturn field + \\\" field\\\" ;\\n\\t}\\n};\\n\",\n            \"module-type\": \"library\",\n            \"title\": \"$:/plugins/flibbles/relink/js/language.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/mangler.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: widget\\n\\nCreates a mangler widget for field validation. This isn't meant to be used\\nby the user. It's only used in Relink configuration.\\n\\n\\\\*/\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\nvar language = require('$:/plugins/flibbles/relink/js/language.js');\\nvar settings = require('$:/plugins/flibbles/relink/js/settings.js');\\n\\nvar RelinkManglerWidget = function(parseTreeNode,options) {\\n\\tthis.initialise(parseTreeNode,options);\\n\\tthis.addEventListeners([\\n\\t\\t{type: \\\"relink-add-field\\\", handler: \\\"handleAddFieldEvent\\\"},\\n\\t\\t{type: \\\"relink-add-operator\\\", handler: \\\"handleAddOperatorEvent\\\"},\\n\\t\\t{type: \\\"relink-add-parameter\\\", handler: \\\"handleAddParameterEvent\\\"},\\n\\t\\t{type: \\\"relink-add-attribute\\\", handler: \\\"handleAddAttributeEvent\\\"}\\n\\t]);\\n};\\n\\nexports.relinkmangler = RelinkManglerWidget;\\n\\nRelinkManglerWidget.prototype = new Widget();\\n\\nRelinkManglerWidget.prototype.handleAddFieldEvent = function(event) {\\n\\tvar param = event.paramObject;\\n\\tif (typeof param !== \\\"object\\\" || !param.field) {\\n\\t\\t// Can't handle it.\\n\\t\\treturn true;\\n\\t}\\n\\tvar trimmedName = param.field.toLowerCase().trim();\\n\\tif (!trimmedName) {\\n\\t\\t// Still can't handle it, but don't warn.\\n\\t\\treturn true;\\n\\t}\\n\\tif(!$tw.utils.isValidFieldName(trimmedName)) {\\n\\t\\tlanguage.alert($tw.language.getString(\\n\\t\\t\\t\\\"InvalidFieldName\\\",\\n\\t\\t\\t{variables:\\n\\t\\t\\t\\t{fieldName: trimmedName}\\n\\t\\t\\t}\\n\\t\\t));\\n\\t} else {\\n\\t\\tadd(this.wiki, \\\"fields\\\", trimmedName);\\n\\t}\\n\\treturn true;\\n};\\n\\n/**Not much validation, even though there are definitely illegal\\n * operator names. If you input on, Relink won't relink it, but it\\n * won't choke on it either. Tiddlywiki will...\\n */\\nRelinkManglerWidget.prototype.handleAddOperatorEvent = function(event) {\\n\\tvar param = event.paramObject;\\n\\tif (param) {\\n\\t\\tadd(this.wiki, \\\"operators\\\", param.operator);\\n\\t}\\n\\treturn true;\\n};\\n\\nRelinkManglerWidget.prototype.handleAddParameterEvent = function(event) {\\n\\tvar param = event.paramObject;\\n\\tif (param && param.macro && param.parameter) {\\n\\t\\tif (/\\\\s/.test(param.macro.trim())) {\\n\\t\\t\\tlanguage.alert(language.getString(\\n\\t\\t\\t\\t\\\"Error/InvalidMacroName\\\",\\n\\t\\t\\t\\t{ variables: {macroName: param.macro},\\n\\t\\t\\t\\t  wiki: this.wiki\\n\\t\\t\\t\\t}\\n\\t\\t\\t));\\n\\t\\t} else if (/[ \\\\/]/.test(param.parameter.trim())) {\\n\\t\\t\\tlanguage.alert(language.getString(\\n\\t\\t\\t\\t\\\"Error/InvalidParameterName\\\",\\n\\t\\t\\t\\t{ variables: {parameterName: param.parameter},\\n\\t\\t\\t\\t  wiki: this.wiki\\n\\t\\t\\t\\t}\\n\\t\\t\\t));\\n\\t\\t} else {\\n\\t\\t\\tadd(this.wiki, \\\"macros\\\", param.macro, param.parameter);\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n};\\n\\nRelinkManglerWidget.prototype.handleAddAttributeEvent = function(event) {\\n\\tvar param = event.paramObject;\\n\\tif (param && param.element && param.attribute) {\\n\\t\\tif (/[ \\\\/]/.test(param.element.trim())) {\\n\\t\\t\\tlanguage.alert(language.getString(\\n\\t\\t\\t\\t\\\"Error/InvalidElementName\\\",\\n\\t\\t\\t\\t{ variables: {elementName: param.element},\\n\\t\\t\\t\\t  wiki: this.wiki\\n\\t\\t\\t\\t}\\n\\t\\t\\t));\\n\\t\\t} else if (/[ \\\\/]/.test(param.attribute.trim())) {\\n\\t\\t\\tlanguage.alert(language.getString(\\n\\t\\t\\t\\t\\\"Error/InvalidAttributeName\\\",\\n\\t\\t\\t\\t{ variables: {attributeName: param.attribute},\\n\\t\\t\\t\\t  wiki: this.wiki\\n\\t\\t\\t\\t}\\n\\t\\t\\t));\\n\\t\\t} else {\\n\\t\\t\\tadd(this.wiki, \\\"attributes\\\", param.element, param.attribute);\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n};\\n\\nfunction add(wiki, category/*, path parts*/) {\\n\\tvar path = \\\"$:/config/flibbles/relink/\\\" + category;\\n\\tfor (var x = 2; x < arguments.length; x++) {\\n\\t\\tvar part = arguments[x];\\n\\t\\t// Abort if it's falsy, or only whitespace. Also, trim spaces\\n\\t\\tif (!part || !(part = part.trim())) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpath = path + \\\"/\\\" + part;\\n\\t}\\n\\tvar def = settings.getDefaultType(wiki);\\n\\twiki.addTiddler({title: path, text: def});\\n};\\n\",\n            \"module-type\": \"widget\",\n            \"title\": \"$:/plugins/flibbles/relink/js/mangler.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/settings.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: library\\n\\nThis handles the fetching and distribution of relink settings.\\n\\n\\\\*/\\n\\nvar fieldTypes = Object.create(null);\\nvar surveyors = [];\\nvar prefix = \\\"$:/config/flibbles/relink/\\\";\\n\\n$tw.modules.forEachModuleOfType(\\\"relinkfieldtype\\\", function(title, exports) {\\n\\tfunction NewType() {};\\n\\tNewType.prototype = exports;\\n\\tNewType.typeName = exports.name;\\n\\tfieldTypes[exports.name] = NewType;\\n\\t// For legacy reasons, some of the field types can go by other names\\n\\tif (exports.aliases) {\\n\\t\\t$tw.utils.each(exports.aliases, function(alias) {\\n\\t\\t\\tfieldTypes[alias] = NewType;\\n\\t\\t});\\n\\t}\\n});\\n\\n$tw.modules.forEachModuleOfType(\\\"relinksurveyor\\\", function(title, exports) {\\n\\tsurveyors.push(exports);\\n});\\n\\nfunction Settings(wiki) {\\n\\tthis.settings = compileSettings(wiki);\\n\\tthis.wiki = wiki;\\n};\\n\\nmodule.exports = Settings;\\n\\n/**Returns a specific relinker.\\n * This is useful for wikitext rules which need to parse a filter or a list\\n */\\nSettings.getType = function(name) {\\n\\tvar Handler = fieldTypes[name];\\n\\treturn Handler ? new Handler() : undefined;\\n};\\n\\nSettings.getTypes = function() {\\n\\t// We don't return fieldTypes, because we don't want it modified,\\n\\t// and we need to filter out legacy names.\\n\\tvar rtn = Object.create(null);\\n\\tfor (var type in fieldTypes) {\\n\\t\\tvar typeObject = fieldTypes[type];\\n\\t\\trtn[typeObject.typeName] = typeObject;\\n\\t}\\n\\treturn rtn;\\n};\\n\\nSettings.getDefaultType = function(wiki) {\\n\\tvar tiddler = wiki.getTiddler(\\\"$:/config/flibbles/relink/settings/default-type\\\");\\n\\tvar defaultType = tiddler && tiddler.fields.text;\\n\\t// make sure the default actually exists, otherwise default\\n\\treturn fieldTypes[defaultType] ? defaultType : \\\"title\\\";\\n};\\n\\nSettings.prototype.survey = function(text, fromTitle, options) {\\n\\tif (text) {\\n\\t\\tfor (var i = 0; i < surveyors.length; i++) {\\n\\t\\t\\tif (surveyors[i].survey(text, fromTitle, options)) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n};\\n\\nSettings.prototype.getAttribute = function(elementName) {\\n\\treturn this.settings.attributes[elementName];\\n};\\n\\nSettings.prototype.getAttributes = function() {\\n\\treturn flatten(this.settings.attributes);\\n};\\n\\n\\nSettings.prototype.getFields = function() {\\n\\treturn this.settings.fields;\\n};\\n\\nSettings.prototype.getOperators = function() {\\n\\treturn this.settings.operators;\\n};\\n\\nSettings.prototype.getMacro = function(macroName) {\\n\\treturn this.settings.macros[macroName];\\n};\\n\\nSettings.prototype.getMacros = function() {\\n\\treturn flatten(this.settings.macros);\\n};\\n\\nSettings.prototype.refresh = function(changes) {\\n\\tfor (var title in changes) {\\n\\t\\tif (title.substr(0, prefix.length) === prefix) {\\n\\t\\t\\tthis.settings = compileSettings(this.wiki);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n};\\n\\n/**Factories define methods that create settings given config tiddlers.\\n * for factory method 'example', it will be called once for each:\\n * \\\"$:/config/flibbles/relink/example/...\\\" tiddler that exists.\\n * the argument \\\"key\\\" will be set to the contents of \\\"...\\\"\\n *\\n * The reason I build relink settings in this convoluted way is to minimize\\n * the number of times tiddlywiki has to run through EVERY tiddler looking\\n * for relink config tiddlers.\\n *\\n * Also, by exporting \\\"factories\\\", anyone who extends relink can patch in\\n * their own factory methods to create settings that are generated exactly\\n * once per rename.\\n */\\nexports.factories = {\\n\\tattributes: function(attributes, data, key) {\\n\\t\\tvar elem = root(key);\\n\\t\\tvar attr = key.substr(elem.length+1);\\n\\t\\tattributes[elem] = attributes[elem] || Object.create(null);\\n\\t\\tattributes[elem][attr] = data;\\n\\t},\\n\\tfields: function(fields, data, name) {\\n\\t\\tfields[name] = data;\\n\\t},\\n\\tmacros: function(macros, data, key) {\\n\\t\\t// We take the last index, not the first, because macro\\n\\t\\t// parameters can't have slashes, but macroNames can.\\n\\t\\tvar name = dir(key);\\n\\t\\tvar arg = key.substr(name.length+1);\\n\\t\\tmacros[name] = macros[name] || Object.create(null);\\n\\t\\tmacros[name][arg] = data;\\n\\t},\\n\\toperators: function(operators, data, name) {\\n\\t\\toperators[name] = data;\\n\\t}\\n};\\n\\nfunction compileSettings(wiki) {\\n\\tvar settings = Object.create(null);\\n\\tfor (var name in exports.factories) {\\n\\t\\tsettings[name] = Object.create(null);\\n\\t}\\n\\twiki.eachShadowPlusTiddlers(function(tiddler, title) {\\n\\t\\tif (title.substr(0, prefix.length) === prefix) {\\n\\t\\t\\tvar remainder = title.substr(prefix.length);\\n\\t\\t\\tvar category = root(remainder);\\n\\t\\t\\tvar factory = exports.factories[category];\\n\\t\\t\\tif (factory) {\\n\\t\\t\\t\\tvar name = remainder.substr(category.length+1);\\n\\t\\t\\t\\tvar Handler = fieldTypes[tiddler.fields.text];\\n\\t\\t\\t\\tif (Handler) {\\n\\t\\t\\t\\t\\tvar data = new Handler();\\n\\t\\t\\t\\t\\tdata.source = title;\\n\\t\\t\\t\\t\\t// Secret feature. You can access a config tiddler's\\n\\t\\t\\t\\t\\t// fields from inside the fieldtype handler. Cool\\n\\t\\t\\t\\t\\t// tricks can be done with this.\\n\\t\\t\\t\\t\\tdata.fields = tiddler.fields;\\n\\t\\t\\t\\t\\tfactory(settings[category], data, name);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n\\treturn settings;\\n};\\n\\n/* Returns first bit of a path. path/to/tiddler -> path\\n */\\nfunction root(string) {\\n\\tvar index = string.indexOf('/');\\n\\tif (index >= 0) {\\n\\t\\treturn string.substr(0, index);\\n\\t}\\n};\\n\\n/* Returns all but the last bit of a path. path/to/tiddler -> path/to\\n */\\nfunction dir(string) {\\n\\tvar index = string.lastIndexOf('/');\\n\\tif (index >= 0) {\\n\\t\\treturn string.substr(0, index);\\n\\t}\\n}\\n\\nfunction flatten(set) {\\n\\tvar signatures = Object.create(null);\\n\\tfor (var outerName in set) {\\n\\t\\tvar setItem = set[outerName];\\n\\t\\tfor (var innerName in setItem) {\\n\\t\\t\\tsignatures[outerName + \\\"/\\\" + innerName] = setItem[innerName];\\n\\t\\t}\\n\\t}\\n\\treturn signatures;\\n};\\n\",\n            \"module-type\": \"library\",\n            \"title\": \"$:/plugins/flibbles/relink/js/settings.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/wikimethods.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: wikimethod\\n\\nIntroduces some utility methods used by Relink.\\n\\n\\\\*/\\n\\nvar MacroSettings = require('$:/plugins/flibbles/relink/js/utils/macroConfig.js');\\nvar Settings = require(\\\"$:/plugins/flibbles/relink/js/settings.js\\\");\\n\\nvar relinkOperations = Object.create(null);\\n$tw.modules.applyMethods('relinkoperator', relinkOperations);\\n\\n/** Returns a pair like this,\\n *  { title: {field: entry, ... }, ... }\\n */\\nexports.getRelinkReport = function(fromTitle, toTitle, options) {\\n\\tvar cache = this.getGlobalCache(\\\"relink-\\\"+fromTitle, function() {\\n\\t\\treturn Object.create(null);\\n\\t});\\n\\tif (!cache[toTitle]) {\\n\\t\\tcache[toTitle] = getFreshRelinkReport(this, fromTitle, toTitle, options);\\n\\t}\\n\\treturn cache[toTitle];\\n};\\n\\nfunction getFreshRelinkReport(wiki, fromTitle, toTitle, options) {\\n\\toptions = options || {};\\n\\toptions.wiki = options.wiki || wiki;\\n\\toptions.settings = wiki.getRelinkConfig();\\n\\tfromTitle = (fromTitle || \\\"\\\").trim();\\n\\ttoTitle = (toTitle || \\\"\\\").trim();\\n\\tvar changeList = Object.create(null);\\n\\tif(fromTitle && toTitle) {\\n\\t\\tvar tiddlerList = wiki.getRelinkableTitles();\\n\\t\\tfor (var i = 0; i < tiddlerList.length; i++) {\\n\\t\\t\\tvar title = tiddlerList[i];\\n\\t\\t\\tvar tiddler = wiki.getTiddler(title);\\n\\t\\t\\t// Don't touch plugins or JavaScript modules\\n\\t\\t\\tif(tiddler\\n\\t\\t\\t&& !tiddler.fields[\\\"plugin-type\\\"]\\n\\t\\t\\t&& tiddler.fields.type !== \\\"application/javascript\\\") {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tvar entries = Object.create(null);\\n\\t\\t\\t\\t\\tfor (var operation in relinkOperations) {\\n\\t\\t\\t\\t\\t\\trelinkOperations[operation](tiddler, fromTitle, toTitle, entries, options);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor (var field in entries) {\\n\\t\\t\\t\\t\\t\\t// So long as there is one key,\\n\\t\\t\\t\\t\\t\\t// add it to the change list.\\n\\t\\t\\t\\t\\t\\tchangeList[title] = entries;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t// Should we test for instanceof Error instead?: yes\\n\\t\\t\\t\\t\\t// Does that work in the testing environment?: no\\n\\t\\t\\t\\t\\tif (e.message) {\\n\\t\\t\\t\\t\\t\\te.message = e.message + \\\"\\\\nWhen relinking '\\\" + title + \\\"'\\\";\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn changeList;\\n};\\n\\nexports.getRelinkableTitles = function() {\\n\\tvar toUpdate = \\\"$:/config/flibbles/relink/to-update\\\";\\n\\tvar self = this;\\n\\treturn this.getCacheForTiddler(toUpdate, \\\"relink-toUpdate\\\", function() {\\n\\t\\tvar tiddler = self.getTiddler(toUpdate);\\n\\t\\tif (tiddler) {\\n\\t\\t\\treturn self.compileFilter(tiddler.fields.text);\\n\\t\\t} else {\\n\\t\\t\\treturn self.allTitles;\\n\\t\\t}\\n\\t})();\\n};\\n\\n\\nexports.getRelinkConfig = function() {\\n\\tif (this._relinkConfig === undefined) {\\n\\t\\tvar settings = new Settings(this);\\n\\t\\tvar config = new MacroSettings(this, settings);\\n\\t\\tconfig.import( \\\"[[$:/core/ui/PageMacros]] [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]]\\\");\\n\\t\\t// All this below is just wiki.addEventListener, only it\\n\\t\\t// puts the event in front, because we need to refresh our\\n\\t\\t// relink settings before updating tiddlers.\\n\\t\\tthis.eventListeners = this.eventListeners || {};\\n\\t\\tthis.eventListeners.change = this.eventListeners.change || [];\\n\\t\\tthis.eventListeners.change.unshift(function(changes) {\\n\\t\\t\\tconfig.refresh(changes);\\n\\t\\t});\\n\\t\\tthis._relinkConfig = config;\\n\\t}\\n\\treturn this._relinkConfig;\\n};\\n\",\n            \"module-type\": \"wikimethod\",\n            \"title\": \"$:/plugins/flibbles/relink/js/wikimethods.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/filteroperators/all_relinkable.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: allfilteroperator\\n\\nFilter function for [all[relinkable]].\\nReturns all tiddlers subject to relinking.\\n\\n\\\\*/\\n\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.relinkable = function(source,prefix,options) {\\n\\treturn options.wiki.getRelinkableTitles();\\n};\\n\\n})();\\n\",\n            \"module-type\": \"allfilteroperator\",\n            \"title\": \"$:/plugins/flibbles/relink/js/filteroperators/all_relinkable.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/filteroperators/impossible.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkfilteroperator\\n\\nThis filter is meant for internal Relink use only, thus it's\\nundocumented and subject to change. Also, it's really not great.\\n\\nGiven an input of targets, (possibly just one), outputs all the tiddlers in\\nwhich Relink would fail to update <<currentTiddler>> to the operand in ALL\\ncases.\\n\\n`[all[tiddlers+system]relink:impossible<toTiddler>]`\\n\\n\\\\*/\\n\\nvar language = require(\\\"$:/plugins/flibbles/relink/js/language.js\\\");\\n\\nexports.impossible = function(source,operator,options) {\\n\\tvar from = options.widget && options.widget.getVariable(\\\"currentTiddler\\\");\\n\\tvar to = operator.operand,\\n\\t\\tresults = [];\\n\\tif (from) {\\n\\t\\tvar records = options.wiki.getRelinkReport(\\n\\t\\t\\tfrom, to, options);\\n\\t\\tsource(function(tiddler, title) {\\n\\t\\t\\tvar fields = records[title];\\n\\t\\t\\tif (fields) {\\n\\t\\t\\t\\tvar impossible = false;\\n\\t\\t\\t\\tfor (var field in fields) {\\n\\t\\t\\t\\t\\tlanguage.eachImpossible(fields[field], function() {\\n\\t\\t\\t\\t\\t\\timpossible = true;\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (impossible) {\\n\\t\\t\\t\\t\\tresults.push(title);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n\\treturn results;\\n};\\n\",\n            \"module-type\": \"relinkfilteroperator\",\n            \"title\": \"$:/plugins/flibbles/relink/js/filteroperators/impossible.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/filteroperators/references.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkfilteroperator\\n\\nGiven a title as an operand, returns all non-shadow tiddlers that have any\\nsort of updatable reference to it.\\n\\n\\n`relink:references[fromTiddler]]`\\n\\nReturns all tiddlers that reference `fromTiddler` somewhere inside them.\\n\\nInput is ignored. Maybe it shouldn't do this.\\nAlso, maybe it should properly recon, instead of fake replacing the title with\\n`__relink_dummy__`\\n\\\\*/\\n\\nexports.references = function(source,operator,options) {\\n\\tvar fromTitle = operator.operand,\\n\\t\\tresults = [];\\n\\tif (fromTitle) {\\n\\t\\tvar records = options.wiki.getRelinkReport(\\n\\t\\t\\tfromTitle, \\\"$:/plugins/flibbles/relink/dummy\\\", options);\\n\\t\\tfor (var title in records) {\\n\\t\\t\\tresults.push(title);\\n\\t\\t}\\n\\t}\\n\\treturn results;\\n};\\n\",\n            \"module-type\": \"relinkfilteroperator\",\n            \"title\": \"$:/plugins/flibbles/relink/js/filteroperators/references.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/filteroperators/relink.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: filteroperator\\n\\nThis filter acts as a namespace for several small, simple filters, such as\\n\\n`[relink:impossible[]]`\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar language = require('$:/plugins/flibbles/relink/js/language.js');\\n\\nvar relinkFilterOperators;\\n\\nfunction getRelinkFilterOperators() {\\n\\tif(!relinkFilterOperators) {\\n\\t\\trelinkFilterOperators = {};\\n\\t\\t$tw.modules.applyMethods(\\\"relinkfilteroperator\\\",\\n\\t\\t                         relinkFilterOperators);\\n\\t}\\n\\treturn relinkFilterOperators;\\n}\\n\\nexports.relink = function(source,operator,options) {\\n\\tvar suffixPair = parseSuffix(operator.suffix);\\n\\tvar relinkFilterOperator = getRelinkFilterOperators()[suffixPair[0]];\\n\\tif (relinkFilterOperator) {\\n\\t\\tvar newOperator = $tw.utils.extend({}, operator);\\n\\t\\tnewOperator.suffix = suffixPair[1];\\n\\t\\treturn relinkFilterOperator(source, newOperator, options);\\n\\t} else {\\n\\t\\treturn [language.getString(\\\"Error/RelinkFilterOperator\\\", options)];\\n\\t}\\n};\\n\\nfunction parseSuffix(suffix) {\\n\\tvar index = suffix? suffix.indexOf(\\\":\\\"): -1;\\n\\tif (index >= 0) {\\n\\t\\treturn [suffix.substr(0, index), suffix.substr(index+1)];\\n\\t} else {\\n\\t\\treturn [suffix];\\n\\t}\\n}\\n\",\n            \"module-type\": \"filteroperator\",\n            \"title\": \"$:/plugins/flibbles/relink/js/filteroperators/relink.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/filteroperators/report.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkfilteroperator\\n\\nGiven a title as an operand, returns a string for each occurrence of that title\\nwithin each input title.\\n\\n[[title]] +[relink:report[fromTiddler]]`\\n\\nReturns string representation of fromTiddler occurrences in title.\\n\\\\*/\\n\\nexports.report = function(source,operator,options) {\\n\\tvar fromTitle = operator.operand,\\n\\t\\tresults = [],\\n\\t\\trecords = options.wiki.getRelinkReport(\\n\\t\\t\\tfromTitle, fromTitle, options);\\n\\tif (fromTitle) {\\n\\t\\tsource(function(tiddler, title) {\\n\\t\\t\\tvar affectedFields = records[title];\\n\\t\\t\\tif (affectedFields) {\\n\\t\\t\\t\\tfor (var field in affectedFields) {\\n\\t\\t\\t\\t\\tvar entry = affectedFields[field];\\n\\t\\t\\t\\t\\tvar signatures = entry.report();\\n\\t\\t\\t\\t\\tresults = results.concat(signatures);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n\\treturn results;\\n};\\n\",\n            \"module-type\": \"relinkfilteroperator\",\n            \"title\": \"$:/plugins/flibbles/relink/js/filteroperators/report.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/filteroperators/signatures.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkfilteroperator\\n\\nThis filter returns all input tiddlers which are a source of\\nrelink configuration.\\n\\n`[all[tiddlers+system]relink:source[macros]]`\\n\\n\\\\*/\\n\\nvar settings = require('$:/plugins/flibbles/relink/js/settings.js');\\n\\nexports.signatures = function(source,operator,options) {\\n\\tvar plugin = operator.operand || null;\\n\\tvar set = getSet(options);\\n\\tif (plugin === \\\"$:/core\\\") {\\n\\t\\t// Core doesn't actually have any settings. We mean Relink\\n\\t\\tplugin = \\\"$:/plugins/flibbles/relink\\\";\\n\\t}\\n\\tvar signatures = [];\\n\\tfor (var signature in set) {\\n\\t\\tvar source = set[signature].source;\\n\\t\\tif (options.wiki.getShadowSource(source) === plugin) {\\n\\t\\t\\tsignatures.push(signature);\\n\\t\\t}\\n\\t}\\n\\treturn signatures;\\n};\\n\\nexports.type = function(source,operator,options) {\\n\\tvar results = [];\\n\\tvar set = getSet(options);\\n\\tsource(function(tiddler, signature) {\\n\\t\\tif (set[signature]) {\\n\\t\\t\\tresults.push(set[signature].name);\\n\\t\\t}\\n\\t});\\n\\treturn results;\\n};\\n\\nexports.types = function(source,operator,options) {\\n\\tvar def = settings.getDefaultType(options.wiki);\\n\\tvar types = Object.keys(settings.getTypes());\\n\\ttypes.sort();\\n\\t// move default to front\\n\\ttypes.sort(function(x,y) { return x === def ? -1 : y === def ? 1 : 0; });\\n\\treturn types;\\n};\\n\\nexports.source = function(source,operator,options) {\\n\\tvar results = [];\\n\\tvar category = operator.suffix;\\n\\tvar set = getSet(options);\\n\\tsource(function(tiddler, signature) {\\n\\t\\tif (set[signature]) {\\n\\t\\t\\tresults.push(set[signature].source);\\n\\t\\t}\\n\\t});\\n\\treturn results;\\n};\\n\\nfunction getSet(options) {\\n\\treturn options.wiki.getGlobalCache(\\\"relink-signatures\\\", function() {\\n\\t\\tvar config = options.wiki.getRelinkConfig();\\n\\t\\tvar set = Object.create(null);\\n\\t\\tvar categories = {\\n\\t\\t\\tattributes: config.getAttributes(),\\n\\t\\t\\tfields: config.getFields(),\\n\\t\\t\\tmacros: config.getMacros(),\\n\\t\\t\\toperators: config.getOperators()};\\n\\t\\t$tw.utils.each(categories, function(list, category) {\\n\\t\\t\\t$tw.utils.each(list, function(item, key) {\\n\\t\\t\\t\\tset[category + \\\"/\\\" + key] = item;\\n\\t\\t\\t});\\n\\t\\t});\\n\\t\\treturn set;\\n\\t});\\n};\\n\",\n            \"module-type\": \"relinkfilteroperator\",\n            \"title\": \"$:/plugins/flibbles/relink/js/filteroperators/signatures.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/filteroperators/splitafter.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/filters/splitbefore.js\\ntype: application/javascript\\nmodule-type: relinkfilteroperator\\n\\nFilter operator that splits each result on the last occurance of the specified separator and returns the last bit.\\n\\nWhat does this have to do with relink? Nothing. I need this so I can render\\nthe configuration menu. I //could// use [splitregexp[]], but then I'd be\\nlimited to Tiddlywiki v5.1.20 or later.\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*\\nExport our filter function\\n*/\\nexports.splitafter = function(source,operator,options) {\\n\\tvar results = [];\\n\\tsource(function(tiddler,title) {\\n\\t\\tvar index = title.lastIndexOf(operator.operand);\\n\\t\\tif(index < 0) {\\n\\t\\t\\t$tw.utils.pushTop(results,title);\\n\\t\\t} else {\\n\\t\\t\\t$tw.utils.pushTop(results,title.substr(index+1));\\n\\t\\t}\\n\\t});\\n\\treturn results;\\n};\\n\\n})();\\n\\n\",\n            \"title\": \"$:/plugins/flibbles/relink/js/filteroperators/splitafter.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"relinkfilteroperator\"\n        },\n        \"$:/plugins/flibbles/relink/js/fieldtypes/filter.js\": {\n            \"text\": \"/*\\\\\\nThis specifies logic for updating filters to reflect title changes.\\n\\\\*/\\n\\nvar refHandler = require(\\\"$:/plugins/flibbles/relink/js/fieldtypes/reference\\\");\\nvar Rebuilder = require(\\\"$:/plugins/flibbles/relink/js/utils/rebuilder\\\");\\nvar EntryNode = require('$:/plugins/flibbles/relink/js/utils/entry');\\n\\nexports.name = \\\"filter\\\";\\n\\nvar FilterEntry = EntryNode.newType(\\\"filter\\\");\\n\\nFilterEntry.prototype.report = function() {\\n\\treturn this.children.map(function(child) {\\n\\t\\tif (!child.report) {\\n\\t\\t\\treturn \\\"\\\";\\n\\t\\t}\\n\\t\\treturn child.report();\\n\\t});\\n};\\n\\nfunction OperatorEntry(operandEntry) { this.entry = operandEntry; };\\nOperatorEntry.prototype.name = \\\"operator\\\";\\n\\nOperatorEntry.prototype.eachChild = function(method) { method(this.entry); }\\n\\nOperatorEntry.prototype.report = function() {\\n\\tvar operand = \\\"\\\";\\n\\tif (this.entry.report) {\\n\\t\\toperand = this.entry.report();\\n\\t}\\n\\tvar op = this.operator;\\n\\tvar brackets = '[]';\\n\\tif (this.type === \\\"indirect\\\") {\\n\\t\\toperand = \\\"{\\\" + operand + \\\"}\\\";\\n\\t} else {\\n\\t\\toperand = \\\"[\\\" + operand + \\\"]\\\";\\n\\t}\\n\\tvar suffix = '';\\n\\tif (op.suffix) {\\n\\t\\tsuffix = \\\":\\\" + op.suffix;\\n\\t}\\n\\treturn \\\"[\\\" + (op.prefix || '') + op.operator + suffix + operand + \\\"]\\\";\\n};\\n\\n/**Returns undefined if no change was made.\\n */\\nexports.relink = function(filter, fromTitle, toTitle, options) {\\n\\tif (!options.settings.survey(filter, fromTitle, options)) {\\n\\t\\treturn undefined;\\n\\t}\\n\\tvar filterEntry = new FilterEntry();\\n\\tvar relinker = new Rebuilder(filter);\\n\\tvar whitelist = options.settings.getOperators();\\n\\tvar p = 0, // Current position in the filter string\\n\\t\\tmatch, noPrecedingWordBarrier,\\n\\t\\twordBarrierRequired=false;\\n\\tvar whitespaceRegExp = /\\\\s+/mg,\\n\\t\\toperandRegExp = /((?:\\\\+|\\\\-|~|=)?)(?:(\\\\[)|(?:\\\"([^\\\"]*)\\\")|(?:'([^']*)')|([^\\\\s\\\\[\\\\]]+))/mg;\\n\\twhile(p < filter.length) {\\n\\t\\t// Skip any whitespace\\n\\t\\twhitespaceRegExp.lastIndex = p;\\n\\t\\tmatch = whitespaceRegExp.exec(filter);\\n\\t\\tnoPrecedingWordBarrier = false;\\n\\t\\tif(match && match.index === p) {\\n\\t\\t\\tp = p + match[0].length;\\n\\t\\t} else if (p != 0) {\\n\\t\\t\\tif (wordBarrierRequired) {\\n\\t\\t\\t\\trelinker.add(' ', p, p);\\n\\t\\t\\t\\twordBarrierRequired = false;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnoPrecedingWordBarrier = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Match the start of the operation\\n\\t\\tif(p < filter.length) {\\n\\t\\t\\tvar val;\\n\\t\\t\\toperandRegExp.lastIndex = p;\\n\\t\\t\\tmatch = operandRegExp.exec(filter);\\n\\t\\t\\tif(!match || match.index !== p) {\\n\\t\\t\\t\\t// It's a bad filter\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\t\\t\\tif(match[1]) { // prefix\\n\\t\\t\\t\\tp++;\\n\\t\\t\\t}\\n\\t\\t\\tif(match[2]) { // Opening square bracket\\n\\t\\t\\t\\t// We check if this is a standalone title,\\n\\t\\t\\t\\t// like `[[MyTitle]]`. We treat those like\\n\\t\\t\\t\\t// `\\\"MyTitle\\\"` or `MyTitle`. Not like a run.\\n\\t\\t\\t\\tvar standaloneTitle = /\\\\[\\\\[([^\\\\]]+)\\\\]\\\\]/g;\\n\\t\\t\\t\\tstandaloneTitle.lastIndex = p;\\n\\t\\t\\t\\tvar alone = standaloneTitle.exec(filter);\\n\\t\\t\\t\\tif (!alone || alone.index != p) {\\n\\t\\t\\t\\t\\t// It's a legit run\\n\\t\\t\\t\\t\\tp =parseFilterOperation(relinker,fromTitle,toTitle,filterEntry,filter,p,whitelist,options);\\n\\t\\t\\t\\t\\tif (p === undefined) {\\n\\t\\t\\t\\t\\t\\t// The filter is malformed\\n\\t\\t\\t\\t\\t\\t// We do nothing.\\n\\t\\t\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbracketTitle = alone[1];\\n\\t\\t\\t\\toperandRegExp.lastIndex = standaloneTitle.lastIndex;\\n\\t\\t\\t\\tval = alone[1];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// standalone Double quoted string, single\\n\\t\\t\\t\\t// quoted string, or noquote ahead.\\n\\t\\t\\t\\tval = match[3] || match[4] || match[5];\\n\\t\\t\\t}\\n\\t\\t\\t// From here on, we're dealing with a standalone title\\n\\t\\t\\t// expression. like `\\\"MyTitle\\\"` or `[[MyTitle]]`\\n\\t\\t\\t// We're much more flexible about relinking these.\\n\\t\\t\\tvar preference = undefined;\\n\\t\\t\\tif (match[3]) {\\n\\t\\t\\t\\tpreference = '\\\"';\\n\\t\\t\\t} else if (match[4]) {\\n\\t\\t\\t\\tpreference = \\\"'\\\";\\n\\t\\t\\t} else if (match[5]) {\\n\\t\\t\\t\\tpreference = '';\\n\\t\\t\\t}\\n\\t\\t\\tif (val === fromTitle) {\\n\\t\\t\\t\\tvar entry = {name: \\\"title\\\"};\\n\\t\\t\\t\\tvar newVal = wrapTitle(toTitle, preference);\\n\\t\\t\\t\\tif (newVal === undefined || (options.inBraces && newVal.indexOf('}}}') >= 0)) {\\n\\t\\t\\t\\t\\tif (!options.placeholder) {\\n\\t\\t\\t\\t\\t\\tentry.impossible = true;\\n\\t\\t\\t\\t\\t\\tfilterEntry.add(entry);\\n\\t\\t\\t\\t\\t\\tp = operandRegExp.lastIndex;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tnewVal = \\\"[<\\\"+options.placeholder.getPlaceholderFor(toTitle,undefined,options)+\\\">]\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (newVal[0] != '[') {\\n\\t\\t\\t\\t\\t// not bracket enclosed\\n\\t\\t\\t\\t\\t// this requires whitespace\\n\\t\\t\\t\\t\\t// arnound it\\n\\t\\t\\t\\t\\tif (noPrecedingWordBarrier && !match[1]) {\\n\\t\\t\\t\\t\\t\\trelinker.add(' ', p, p);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twordBarrierRequired = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tentry.output = toTitle;\\n\\t\\t\\t\\tentry.operator = {operator: \\\"title\\\"};\\n\\t\\t\\t\\tentry.quotation = preference;\\n\\t\\t\\t\\tfilterEntry.add(entry);\\n\\t\\t\\t\\trelinker.add(newVal,p,operandRegExp.lastIndex);\\n\\t\\t\\t}\\n\\t\\t\\tp = operandRegExp.lastIndex;\\n\\t\\t}\\n\\t}\\n\\tif (filterEntry.children.length > 0) {\\n\\t\\tfilterEntry.output = relinker.results();\\n\\t\\treturn filterEntry;\\n\\t}\\n\\treturn undefined;\\n};\\n\\n/* Same as this.relink, except this has the added constraint that the return\\n * value must be able to be wrapped in curly braces. (i.e. '{{{...}}}')\\n */\\nexports.relinkInBraces = function(filter, fromTitle, toTitle, options) {\\n\\tvar braceOptions = $tw.utils.extend({inBraces: true}, options);\\n\\tvar entry = this.relink(filter, fromTitle, toTitle, braceOptions);\\n\\tif (entry && entry.output && !canBeInBraces(entry.output)) {\\n\\t\\t// It was possible, but it won't fit in braces, so we must give up\\n\\t\\tdelete entry.output;\\n\\t\\tentry.impossible = true;\\n\\t}\\n\\treturn entry;\\n};\\n\\nfunction wrapTitle(value, preference) {\\n\\tvar choices = {\\n\\t\\t\\\"\\\": function(v) {return /^[^\\\\s\\\\[\\\\]]*[^\\\\s\\\\[\\\\]\\\\}]$/.test(v); },\\n\\t\\t\\\"[\\\": canBePrettyOperand,\\n\\t\\t\\\"'\\\": function(v) {return v.indexOf(\\\"'\\\") < 0; },\\n\\t\\t'\\\"': function(v) {return v.indexOf('\\\"') < 0; }\\n\\t};\\n\\tvar wrappers = {\\n\\t\\t\\\"\\\": function(v) {return v; },\\n\\t\\t\\\"[\\\": function(v) {return \\\"[[\\\"+v+\\\"]]\\\"; },\\n\\t\\t\\\"'\\\": function(v) {return \\\"'\\\"+v+\\\"'\\\"; },\\n\\t\\t'\\\"': function(v) {return '\\\"'+v+'\\\"'; }\\n\\t};\\n\\tif (choices[preference]) {\\n\\t\\tif (choices[preference](value)) {\\n\\t\\t\\treturn wrappers[preference](value);\\n\\t\\t}\\n\\t}\\n\\tfor (var quote in choices) {\\n\\t\\tif (choices[quote](value)) {\\n\\t\\t\\treturn wrappers[quote](value);\\n\\t\\t}\\n\\t}\\n\\t// No quotes will work on this\\n\\treturn undefined;\\n}\\n\\nfunction parseFilterOperation(relinker, fromTitle, toTitle, logger, filterString, p, whitelist, options) {\\n\\tvar nextBracketPos, operator;\\n\\t// Skip the starting square bracket\\n\\tif(filterString.charAt(p++) !== \\\"[\\\") {\\n\\t\\t// Missing [ in filter expression\\n\\t\\treturn undefined;\\n\\t}\\n\\t// Process each operator in turn\\n\\tdo {\\n\\t\\toperator = {};\\n\\t\\t// Check for an operator prefix\\n\\t\\tif(filterString.charAt(p) === \\\"!\\\") {\\n\\t\\t\\toperator.prefix = \\\"!\\\";\\n\\t\\t\\tp++;\\n\\t\\t}\\n\\t\\t// Get the operator name\\n\\t\\tnextBracketPos = filterString.substring(p).search(/[\\\\[\\\\{<\\\\/]/);\\n\\t\\tif(nextBracketPos === -1) {\\n\\t\\t\\t// Missing [ in filter expression\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\t\\tnextBracketPos += p;\\n\\t\\tvar bracket = filterString.charAt(nextBracketPos);\\n\\t\\toperator.operator = filterString.substring(p,nextBracketPos);\\n\\n\\t\\t// Any suffix?\\n\\t\\tvar colon = operator.operator.indexOf(':');\\n\\t\\tif(colon > -1) {\\n\\t\\t\\toperator.suffix = operator.operator.substring(colon + 1);\\n\\t\\t\\toperator.operator = operator.operator.substring(0,colon) || \\\"field\\\";\\n\\t\\t}\\n\\t\\t// Empty operator means: title\\n\\t\\telse if(operator.operator === \\\"\\\") {\\n\\t\\t\\toperator.operator = \\\"title\\\";\\n\\t\\t}\\n\\n\\t\\tvar entry = undefined, type;\\n\\n\\t\\tp = nextBracketPos + 1;\\n\\t\\tswitch (bracket) {\\n\\t\\t\\tcase \\\"{\\\": // Curly brackets\\n\\t\\t\\t\\ttype = \\\"indirect\\\";\\n\\t\\t\\t\\tnextBracketPos = filterString.indexOf(\\\"}\\\",p);\\n\\t\\t\\t\\tvar operand = filterString.substring(p,nextBracketPos);\\n\\t\\t\\t\\tentry = refHandler.relinkInBraces(operand, fromTitle, toTitle, options);\\n\\t\\t\\t\\tif (entry && entry.output) {\\n\\t\\t\\t\\t\\t// We don't check the whitelist.\\n\\t\\t\\t\\t\\t// All indirect operands convert.\\n\\t\\t\\t\\t\\trelinker.add(entry.output,p,nextBracketPos);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"[\\\": // Square brackets\\n\\t\\t\\t\\ttype = \\\"string\\\";\\n\\t\\t\\t\\tnextBracketPos = filterString.indexOf(\\\"]\\\",p);\\n\\t\\t\\t\\tvar operand = filterString.substring(p,nextBracketPos);\\n\\t\\t\\t\\t// Check if this is a relevant operator\\n\\t\\t\\t\\tvar handler = fieldType(whitelist, operator);\\n\\t\\t\\t\\tif (!handler) {\\n\\t\\t\\t\\t\\t// This operator isn't managed. Bye.\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tentry = handler.relink(operand, fromTitle, toTitle, options);\\n\\t\\t\\t\\tif (!entry) {\\n\\t\\t\\t\\t\\t// The fromTitle wasn't in the operand.\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!entry.output) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar wrapped;\\n\\t\\t\\t\\tif (!canBePrettyOperand(entry.output) || (options.inBraces && entry.output.indexOf('}}}') >= 0)) {\\n\\t\\t\\t\\t\\tif (!options.placeholder) {\\n\\t\\t\\t\\t\\t\\tdelete entry.output;\\n\\t\\t\\t\\t\\t\\tentry.impossible = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tvar ph = options.placeholder.getPlaceholderFor(entry.output, handler.name, options);\\n\\t\\t\\t\\t\\twrapped = \\\"<\\\"+ph+\\\">\\\";\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\twrapped = \\\"[\\\"+entry.output+\\\"]\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trelinker.add(wrapped, p-1, nextBracketPos+1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"<\\\": // Angle brackets\\n\\t\\t\\t\\tnextBracketPos = filterString.indexOf(\\\">\\\",p);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"/\\\": // regexp brackets\\n\\t\\t\\t\\tvar rex = /^((?:[^\\\\\\\\\\\\/]*|\\\\\\\\.)*)\\\\/(?:\\\\(([mygi]+)\\\\))?/g,\\n\\t\\t\\t\\t\\trexMatch = rex.exec(filterString.substring(p));\\n\\t\\t\\t\\tif(rexMatch) {\\n\\t\\t\\t\\t\\tnextBracketPos = p + rex.lastIndex - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t// Unterminated regular expression\\n\\t\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif (entry) {\\n\\t\\t\\tvar operatorEntry = new OperatorEntry(entry);\\n\\t\\t\\toperatorEntry.operator = operator;\\n\\t\\t\\toperatorEntry.type = type;\\n\\t\\t\\tlogger.add(operatorEntry);\\n\\t\\t}\\n\\n\\t\\tif(nextBracketPos === -1) {\\n\\t\\t\\t// Missing closing bracket in filter expression\\n\\t\\t\\t// return undefined;\\n\\t\\t}\\n\\t\\tp = nextBracketPos + 1;\\n\\n\\t} while(filterString.charAt(p) !== \\\"]\\\");\\n\\t// Skip the ending square bracket\\n\\tif(filterString.charAt(p++) !== \\\"]\\\") {\\n\\t\\t// Missing ] in filter expression\\n\\t\\treturn undefined;\\n\\t}\\n\\t// Return the parsing position\\n\\treturn p;\\n}\\n\\n// Returns the relinker needed for a given operator, or returns undefined.\\nfunction fieldType(whitelist, operator) {\\n\\treturn (operator.suffix &&\\n\\t        whitelist[operator.operator + \\\":\\\" + operator.suffix]) ||\\n\\t        whitelist[operator.operator];\\n};\\n\\nfunction canBePrettyOperand(value) {\\n\\treturn value.indexOf(']') < 0;\\n};\\n\\nfunction canBeInBraces(value) {\\n\\treturn value.indexOf(\\\"}}}\\\") < 0 && value.substr(value.length-2) !== '}}';\\n};\\n\",\n            \"module-type\": \"relinkfieldtype\",\n            \"title\": \"$:/plugins/flibbles/relink/js/fieldtypes/filter.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/fieldtypes/list.js\": {\n            \"text\": \"/*\\\\\\nThis manages replacing titles that occur within stringLists, like,\\n\\nTiddlerA [[Tiddler with spaces]] [[Another Title]]\\n\\\\*/\\n\\nexports.name = \\\"list\\\";\\n\\n/**Returns undefined if no change was made.\\n * Parameter: value can literally be a list. This can happen for builtin\\n *            types 'list' and 'tag'. In those cases, we also return list.\\n */\\nexports.relink = function(value, fromTitle, toTitle, options) {\\n\\tvar isModified = false,\\n\\t\\tactualList = false,\\n\\t\\tlist;\\n\\tif (typeof value !== \\\"string\\\") {\\n\\t\\t// Not a string. Must be a list.\\n\\t\\t// clone it, since we may make changes to this possibly\\n\\t\\t// frozen list.\\n\\t\\tlist = (value || []).slice(0);\\n\\t\\tactualList = true;\\n\\t} else {\\n\\t\\tlist = $tw.utils.parseStringArray(value || \\\"\\\");\\n\\t}\\n\\t$tw.utils.each(list,function (title,index) {\\n\\t\\tif(title === fromTitle) {\\n\\t\\t\\tlist[index] = toTitle;\\n\\t\\t\\tisModified = true;\\n\\t\\t}\\n\\t});\\n\\tif (isModified) {\\n\\t\\tvar entry = {name: \\\"list\\\"};\\n\\t\\t// It doesn't parse correctly alone, it won't\\n\\t\\t// parse correctly in any list.\\n\\t\\tif (!canBeListItem(toTitle)) {\\n\\t\\t\\tentry.impossible = true;\\n\\t\\t} else if (actualList) {\\n\\t\\t\\tentry.output = list;\\n\\t\\t} else {\\n\\t\\t\\tentry.output = $tw.utils.stringifyList(list);\\n\\t\\t}\\n\\t\\treturn entry;\\n\\t}\\n\\treturn undefined;\\n};\\n\\nfunction canBeListItem(value) {\\n\\tvar regexp = /\\\\]\\\\][^\\\\S\\\\xA0]/m;\\n\\treturn !regexp.test(value);\\n};\\n\",\n            \"module-type\": \"relinkfieldtype\",\n            \"title\": \"$:/plugins/flibbles/relink/js/fieldtypes/list.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/fieldtypes/reference.js\": {\n            \"text\": \"/*\\\\\\nThis manages replacing titles that occur inside text references,\\n\\ntiddlerTitle\\ntiddlerTitle!!field\\n!!field\\ntiddlerTitle##propertyIndex\\n\\\\*/\\n\\nexports.name = \\\"reference\\\";\\n\\nfunction ReferenceEntry(reference) {\\n\\tthis.reference = reference;\\n};\\nReferenceEntry.prototype.name = \\\"reference\\\";\\n\\nReferenceEntry.prototype.report = function() {\\n\\tif (this.reference.field) {\\n\\t\\treturn [\\\"!!\\\" + this.reference.field];\\n\\t}\\n\\tif (this.reference.index) {\\n\\t\\treturn [\\\"##\\\" + this.reference.index];\\n\\t}\\n\\treturn [\\\"\\\"];\\n};\\n\\nexports.relink = function(value, fromTitle, toTitle, options) {\\n\\tvar entry;\\n\\tif (value) {\\n\\t\\tvar reference = $tw.utils.parseTextReference(value);\\n\\t\\tif (reference.title === fromTitle) {\\n\\t\\t\\tentry = new ReferenceEntry(reference);\\n\\t\\t\\tif (!exports.canBePretty(toTitle)) {\\n\\t\\t\\t\\tentry.impossible = true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treference.title = toTitle;\\n\\t\\t\\t\\tentry.output = exports.toString(reference);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn entry;\\n};\\n\\n/* Same as this.relink, except this has the added constraint that the return\\n * value must be able to be wrapped in curly braces.\\n */\\nexports.relinkInBraces = function(value, fromTitle, toTitle, options) {\\n\\tvar log = this.relink(value, fromTitle, toTitle, options);\\n\\tif (log && log.output && toTitle.indexOf(\\\"}\\\") >= 0) {\\n\\t\\tdelete log.output;\\n\\t\\tlog.impossible = true;\\n\\t}\\n\\treturn log;\\n};\\n\\nexports.toString = function(textReference) {\\n\\tvar title = textReference.title || '';\\n\\tif (textReference.field) {\\n\\t\\treturn title + \\\"!!\\\" + textReference.field;\\n\\t} else if (textReference.index) {\\n\\t\\treturn title + \\\"##\\\" + textReference.index;\\n\\t}\\n\\treturn title;\\n};\\n\\nexports.canBePretty = function(title)  {\\n\\treturn !title || (title.indexOf(\\\"!!\\\") < 0 && title.indexOf(\\\"##\\\") < 0);\\n};\\n\",\n            \"module-type\": \"relinkfieldtype\",\n            \"title\": \"$:/plugins/flibbles/relink/js/fieldtypes/reference.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/fieldtypes/title.js\": {\n            \"text\": \"/*\\\\\\nThis specifies logic for replacing a single-tiddler field. This is the\\nsimplest kind of field type. One title swaps out for the other.\\n\\\\*/\\n\\n// NOTE TO MODDERS: If you're making your own field types, the name must be\\n//                  alpha characters only.\\nexports.name = 'title';\\n\\n/**Returns undefined if no change was made.\\n */\\nexports.relink = function(value, fromTitle, toTitle, options) {\\n\\tif (value === fromTitle) {\\n\\t\\treturn {name: \\\"title\\\", output: toTitle};\\n\\t}\\n\\treturn undefined;\\n};\\n\\n// This is legacy support for when 'title' was known as 'field'\\nexports.aliases = ['field', 'yes'];\\n\",\n            \"module-type\": \"relinkfieldtype\",\n            \"title\": \"$:/plugins/flibbles/relink/js/fieldtypes/title.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/fieldtypes/wikitext.js\": {\n            \"text\": \"/*\\\\\\nThis specifies logic for updating filters to reflect title changes.\\n\\\\*/\\n\\nexports.name = \\\"wikitext\\\";\\n\\nvar type = 'text/vnd.tiddlywiki';\\n\\nvar WikiParser = require(\\\"$:/core/modules/parsers/wikiparser/wikiparser.js\\\")[type];\\nvar Rebuilder = require(\\\"$:/plugins/flibbles/relink/js/utils/rebuilder.js\\\");\\nvar EntryNode = require('$:/plugins/flibbles/relink/js/utils/entry');\\n\\nvar WikitextEntry = EntryNode.newType(\\\"wikitext\\\");\\n\\nfunction collectRules() {\\n\\tvar rules = Object.create(null);\\n\\t$tw.modules.forEachModuleOfType(\\\"relinkwikitextrule\\\", function(title, exports) {\\n\\t\\tvar names = exports.name;\\n\\t\\tif (typeof names === \\\"string\\\") {\\n\\t\\t\\tnames = [names];\\n\\t\\t}\\n\\t\\tfor (var i = 0; i < names.length; i++) {\\n\\t\\t\\trules[names[i]] = exports;\\n\\t\\t}\\n\\t});\\n\\treturn rules;\\n}\\n\\nfunction WikiRelinker(type, text, fromTitle, toTitle, options) {\\n\\tthis.entry = new WikitextEntry();\\n\\tthis.builder = new Rebuilder(text);\\n\\tthis.options = options;\\n\\tif (!this.relinkMethodsInjected) {\\n\\t\\tvar rules = collectRules();\\n\\t\\t$tw.utils.each([this.pragmaRuleClasses, this.blockRuleClasses, this.inlineRuleClasses], function(classList) {\\n\\t\\t\\tfor (var name in classList) {\\n\\t\\t\\t\\tif (rules[name]) {\\n\\t\\t\\t\\t\\tdelete rules[name].name;\\n\\t\\t\\t\\t\\t$tw.utils.extend(classList[name].prototype, rules[name]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tWikiRelinker.prototype.relinkMethodsInjected = true;\\n\\t}\\n\\tthis.fromTitle = fromTitle;\\n\\tthis.toTitle = toTitle;\\n\\tWikiParser.call(this, type, text, options);\\n};\\n\\nWikiRelinker.prototype = Object.create(WikiParser.prototype);\\n\\nWikiRelinker.prototype.parsePragmas = function() {\\n\\twhile (true) {\\n\\t\\tthis.skipWhitespace();\\n\\t\\tif (this.pos >= this.sourceLength) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar nextMatch = this.findNextMatch(this.pragmaRules, this.pos);\\n\\t\\tif (!nextMatch || nextMatch.matchIndex !== this.pos) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tthis.relinkRule(nextMatch);\\n\\t}\\n\\treturn [];\\n};\\n\\nWikiRelinker.prototype.parseInlineRunUnterminated = function(options) {\\n\\tvar nextMatch = this.findNextMatch(this.inlineRules, this.pos);\\n\\twhile (this.pos < this.sourceLength && nextMatch) {\\n\\t\\tif (nextMatch.matchIndex > this.pos) {\\n\\t\\t\\tthis.pos = nextMatch.matchIndex;\\n\\t\\t}\\n\\t\\tthis.relinkRule(nextMatch);\\n\\t\\tnextMatch = this.findNextMatch(this.inlineRules, this.pos);\\n\\t}\\n\\tthis.pos = this.sourceLength;\\n};\\n\\nWikiRelinker.prototype.parseInlineRunTerminated = function(terminatorRegExp,options) {\\n\\toptions = options || {};\\n\\tterminatorRegExp.lastIndex = this.pos;\\n\\tvar terminatorMatch = terminatorRegExp.exec(this.source);\\n\\tvar inlineRuleMatch = this.findNextMatch(this.inlineRules,this.pos);\\n\\twhile(this.pos < this.sourceLength && (terminatorMatch || inlineRuleMatch)) {\\n\\t\\tif (terminatorMatch) {\\n\\t\\t\\tif (!inlineRuleMatch || inlineRuleMatch.matchIndex >= terminatorMatch.index) {\\n\\t\\t\\t\\tthis.pos = terminatorMatch.index;\\n\\t\\t\\t\\tif (options.eatTerminator) {\\n\\t\\t\\t\\t\\tthis.pos += terminatorMatch[0].length;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn [];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (inlineRuleMatch) {\\n\\t\\t\\tif (inlineRuleMatch.matchIndex > this.pos) {\\n\\t\\t\\t\\tthis.pos = inlineRuleMatch.matchIndex;\\n\\t\\t\\t}\\n\\t\\t\\tthis.relinkRule(inlineRuleMatch);\\n\\t\\t\\tinlineRuleMatch = this.findNextMatch(this.inlineRules, this.pos);\\n\\t\\t\\tterminatorRegExp.lastIndex = this.pos;\\n\\t\\t\\tterminatorMatch = terminatorRegExp.exec(this.source);\\n\\t\\t}\\n\\t}\\n\\tthis.pos = this.sourceLength;\\n\\treturn [];\\n\\n};\\n\\nWikiRelinker.prototype.parseBlock = function(terminatorRegExp) {\\n\\tvar terminatorRegExp = /(\\\\r?\\\\n\\\\r?\\\\n)/mg;\\n\\tthis.skipWhitespace();\\n\\tif (this.pos >= this.sourceLength) {\\n\\t\\treturn [];\\n\\t}\\n\\tvar nextMatch = this.findNextMatch(this.blockRules, this.pos);\\n\\tif(nextMatch && nextMatch.matchIndex === this.pos) {\\n\\t\\treturn this.relinkRule(nextMatch);\\n\\t}\\n\\treturn this.parseInlineRun(terminatorRegExp);\\n};\\n\\nWikiRelinker.prototype.relinkRule = function(ruleInfo) {\\n\\tif (ruleInfo.rule.relink) {\\n\\t\\tvar newEntry = ruleInfo.rule.relink(this.source, this.fromTitle, this.toTitle, this.options);\\n\\t\\tif (newEntry !== undefined) {\\n\\t\\t\\tthis.entry.add(newEntry);\\n\\t\\t\\tif (newEntry.output) {\\n\\t\\t\\t\\tthis.builder.add(newEntry.output, ruleInfo.matchIndex, this.pos);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else {\\n\\t\\tif (ruleInfo.rule.matchRegExp !== undefined) {\\n\\t\\t\\tthis.pos = ruleInfo.rule.matchRegExp.lastIndex;\\n\\t\\t} else {\\n\\t\\t\\t// We can't easily determine the end of this\\n\\t\\t\\t// rule match. We'll \\\"parse\\\" it so that\\n\\t\\t\\t// parser.pos gets updated, but we throw away\\n\\t\\t\\t// the results.\\n\\t\\t\\truleInfo.rule.parse();\\n\\t\\t}\\n\\t}\\n};\\n\\nWikiRelinker.prototype.amendRules = function(type, names) {\\n\\tvar only;\\n\\tWikiParser.prototype.amendRules.call(this, type, names);\\n\\tif (type === \\\"only\\\") {\\n\\t\\tonly = true;\\n\\t} else if (type === \\\"except\\\") {\\n\\t\\tonly = false;\\n\\t} else {\\n\\t\\treturn;\\n\\t}\\n\\tif (only !== (names.indexOf(\\\"macrodef\\\") >= 0)) {\\n\\t\\tthis.options.placeholder = undefined\\n\\t}\\n\\tif (only !== (names.indexOf(\\\"html\\\") >= 0)) {\\n\\t\\tthis.options.noWidgets = true;\\n\\t}\\n\\tif (only !== (names.indexOf(\\\"prettylink\\\") >= 0)) {\\n\\t\\tthis.options.noPrettylinks = true;\\n\\t}\\n};\\n\\nexports.relink = function(wikitext, fromTitle, toTitle, options) {\\n\\t// fromTitle doesn't even show up plaintext. No relinking to do.\\n\\tif (!options.settings.survey(wikitext, fromTitle, options)) {\\n\\t\\treturn undefined;\\n\\t}\\n\\tvar matchingRule,\\n\\t\\tnewOptions = $tw.utils.extend({}, options);\\n\\tnewOptions.settings = options.settings.createChildLibrary(options.currentTiddler);\\n\\tvar parser = new WikiRelinker(options.type, wikitext, fromTitle, toTitle, newOptions);\\n\\tif (parser.entry.children.length > 0) {\\n\\t\\tparser.entry.output = parser.builder.results();\\n\\t\\treturn parser.entry;\\n\\t}\\n\\treturn undefined;\\n};\\n\",\n            \"module-type\": \"relinkfieldtype\",\n            \"title\": \"$:/plugins/flibbles/relink/js/fieldtypes/wikitext.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/fields.js\": {\n            \"text\": \"/*\\\\\\n\\nHandles all fields specified in the plugin configuration. Currently, this\\nonly supports single-value fields.\\n\\n\\\\*/\\n\\n/*jslint node: false, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar settings = require('$:/plugins/flibbles/relink/js/settings.js');\\nvar log = require('$:/plugins/flibbles/relink/js/language.js').logRelink;\\nvar EntryNode = require('$:/plugins/flibbles/relink/js/utils/entry');\\n\\nvar FieldEntry = EntryNode.newType(\\\"field\\\");\\n\\nFieldEntry.prototype.report = function() {\\n\\tvar self = this;\\n\\tvar output = [];\\n\\t$tw.utils.each(this.children, function(child) {\\n\\t\\tif (child.report) {\\n\\t\\t\\t$tw.utils.each(child.report(), function(report) {\\n\\t\\t\\t\\tif (report) {\\n\\t\\t\\t\\t\\toutput.push(self.field + \\\": \\\" + report);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\toutput.push(self.field);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\toutput.push(self.field);\\n\\t\\t}\\n\\t});\\n\\treturn output;\\n};\\n\\nexports['fields'] = function(tiddler, fromTitle, toTitle, changes, options) {\\n\\tvar fields = options.settings.getFields();\\n\\t$tw.utils.each(fields, function(handler, field) {\\n\\t\\tvar input = tiddler.fields[field];\\n\\t\\tvar entry = handler.relink(input, fromTitle, toTitle, options);\\n\\t\\tif (entry !== undefined) {\\n\\t\\t\\tvar fieldEntry = new FieldEntry();\\n\\t\\t\\tfieldEntry.field = field;\\n\\t\\t\\tfieldEntry.output = entry.output;\\n\\t\\t\\tfieldEntry.add(entry);\\n\\t\\t\\tchanges[field] = fieldEntry;\\n\\t\\t}\\n\\t});\\n};\\n\",\n            \"module-type\": \"relinkoperator\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/fields.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text.js\": {\n            \"text\": \"/*\\\\\\n\\nDepending on the tiddler type, this will apply textOperators which may\\nrelink titles within the body.\\n\\n\\\\*/\\n\\n/*jslint node: false, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar defaultOperator = \\\"text/vnd.tiddlywiki\\\";\\n\\nvar textOperators = Object.create(null);\\n$tw.modules.applyMethods('relinktextoperator', textOperators);\\n\\n// $:/DefaultTiddlers is a tiddler which has type \\\"text/vnd.tiddlywiki\\\",\\n// but it lies. It doesn't contain wikitext. It contains a filter, so\\n// we pretend it has a filter type.\\n// If you want to be able to add more exceptions for your plugin, let me know.\\nvar exceptions = {\\n\\t\\\"$:/DefaultTiddlers\\\": \\\"text/x-tiddler-filter\\\"\\n};\\n\\nexports['text'] = function(tiddler, fromTitle, toTitle, changes, options) {\\n\\tvar fields = tiddler.fields;\\n\\tif (fields.text) {\\n\\t\\tvar type = exceptions[fields.title] || fields.type || defaultOperator;\\n\\t\\tif (textOperators[type]) {\\n\\t\\t\\tvar entry = textOperators[type].call(this, tiddler, fromTitle, toTitle, options);\\n\\t\\t\\tif (entry) {\\n\\t\\t\\t\\tchanges.text = entry;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\",\n            \"module-type\": \"relinkoperator\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/filtertext.js\": {\n            \"text\": \"/*\\\\\\n\\nThis relinks tiddlers which contain filters in their body, as oppose to\\nwikitext.\\n\\n\\\\*/\\n\\n/*jslint node: false, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar filterHandler = require(\\\"$:/plugins/flibbles/relink/js/settings\\\").getType('filter');\\n\\nexports['text/x-tiddler-filter'] = function(tiddler, fromTitle, toTitle, options) {\\n\\treturn filterHandler.relink(tiddler.fields.text, fromTitle, toTitle, options)\\n};\\n\",\n            \"module-type\": \"relinktextoperator\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/filtertext.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext.js\": {\n            \"text\": \"/*\\\\\\n\\nChecks for fromTitle in a tiddler's text. If found, sees if it's relevant,\\nand tries to swap it out if it is.\\n\\n\\\\*/\\n\\n/*jslint node: false, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar type = 'text/vnd.tiddlywiki';\\nvar Placeholder = require(\\\"$:/plugins/flibbles/relink/js/utils/placeholder.js\\\");\\nvar settings = require('$:/plugins/flibbles/relink/js/settings.js');\\nvar wikitextHandler = settings.getType('wikitext');\\n\\nexports[type] = function(tiddler, fromTitle, toTitle, options) {\\n\\tvar placeholder = new Placeholder();\\n\\tvar currentOptions = $tw.utils.extend(\\n\\t\\t{\\n\\t\\t\\tcurrentTiddler: tiddler.fields.title,\\n\\t\\t\\tplaceholder: placeholder\\n\\t\\t}, options);\\n\\tvar entry = wikitextHandler.relink(tiddler.fields.text, fromTitle, toTitle, currentOptions);\\n\\tif (entry && entry.output) {\\n\\t\\t// If there's output, we've also got to prepend any macros\\n\\t\\t// that the placeholder defined.\\n\\t\\tvar preamble = placeholder.getPreamble();\\n\\t\\tentry.output = preamble + entry.output;\\n\\t}\\n\\treturn entry;\\n}\\n\",\n            \"module-type\": \"relinktextoperator\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/code.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nHandles code blocks. Or rather //doesn't// handle them, since we should\\nignore their contents.\\n\\n\\\"`` [[Renamed Title]] ``\\\" will remain unchanged.\\n\\n\\\\*/\\n\\nexports.name = [\\\"codeinline\\\", \\\"codeblock\\\"];\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tvar reEnd;\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\t// I'm lazy. This relink method works for both codeblock and codeinline\\n\\tif (this.match[0].length > 2) {\\n\\t\\t// Must be a codeblock\\n\\t\\treEnd = /\\\\r?\\\\n```$/mg;\\n\\t} else {\\n\\t\\t// Must be a codeinline\\n\\t\\treEnd = new RegExp(this.match[1], \\\"mg\\\");\\n\\t}\\n\\treEnd.lastIndex = this.parser.pos;\\n\\tvar match = reEnd.exec(text);\\n\\tif (match) {\\n\\t\\tthis.parser.pos = match.index + match[0].length;\\n\\t} else {\\n\\t\\tthis.parser.pos = this.parser.sourceLength;\\n\\t}\\n\\treturn undefined;\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/code.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/comment.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nHandles comment blocks. Or rather //doesn't// handle them, since we should\\nignore their contents.\\n\\n\\\"<!-- [[Renamed Title]] -->\\\" will remain unchanged.\\n\\n\\\\*/\\n\\nexports.name = [\\\"commentinline\\\", \\\"commentblock\\\"];\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tthis.parser.pos = this.endMatchRegExp.lastIndex;\\n\\treturn undefined;\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/comment.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/filteredtransclude.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nHandles replacement of filtered transclusions in wiki text like,\\n\\n{{{ [tag[docs]] }}}\\n{{{ [tag[docs]] |tooltip}}}\\n{{{ [tag[docs]] ||TemplateTitle}}}\\n{{{ [tag[docs]] |tooltip||TemplateTitle}}}\\n{{{ [tag[docs]] }}width:40;height:50;}.class.class\\n\\nThis renames both the list and the template field.\\n\\n\\\\*/\\n\\nexports.name = ['filteredtranscludeinline', 'filteredtranscludeblock'];\\n\\nvar filterHandler = require(\\\"$:/plugins/flibbles/relink/js/settings\\\").getType('filter');\\nvar utils = require(\\\"./utils.js\\\");\\nvar EntryNode = require('$:/plugins/flibbles/relink/js/utils/entry');\\n\\nvar FilteredTranscludeEntry = EntryNode.newType(\\\"filteredtransclude\\\");\\n\\nFilteredTranscludeEntry.prototype.report = function() {\\n\\tvar output = [];\\n\\tvar self = this;\\n\\t$tw.utils.each(this.children, function(child) {\\n\\t\\tif (child.name === \\\"filter\\\") {\\n\\t\\t\\tvar append = \\\"}}}\\\";\\n\\t\\t\\tif (self.template) {\\n\\t\\t\\t\\tappend = \\\"||\\\" + self.template + append;\\n\\t\\t\\t}\\n\\t\\t\\t$tw.utils.each(child.report(), function(report) {\\n\\t\\t\\t\\toutput.push(\\\"{{{\\\" + report + append);\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\t// Must be the template\\n\\t\\t\\toutput.push(\\\"{{{\\\" + self.filter + \\\"||}}}\\\");\\n\\t\\t}\\n\\t});\\n\\treturn output;\\n};\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tvar m = this.match;\\n\\t\\tfilter = m[1],\\n\\t\\ttooltip = m[2],\\n\\t\\ttemplate = m[3],\\n\\t\\tstyle = m[4],\\n\\t\\tclasses = m[5],\\n\\t\\tparser = this.parser,\\n\\t\\tentry = new FilteredTranscludeEntry();\\n\\tparser.pos = this.matchRegExp.lastIndex;\\n\\tvar modified = false;\\n\\n\\tvar filterEntry = filterHandler.relink(filter, fromTitle, toTitle, options);\\n\\tif (filterEntry !== undefined) {\\n\\t\\tentry.add(filterEntry);\\n\\t\\tif (filterEntry.output) {\\n\\t\\t\\tmodified = true;\\n\\t\\t\\tfilter = filterEntry.output;\\n\\t\\t}\\n\\t}\\n\\n\\tif ($tw.utils.trim(template) === fromTitle) {\\n\\t\\t// preserves user-inputted whitespace\\n\\t\\ttemplate = template.replace(fromTitle, toTitle);\\n\\t\\tentry.add({name: \\\"title\\\", output: template});\\n\\t\\tmodified = true;\\n\\t}\\n\\tif (!modified) {\\n\\t\\tif (entry.children.length <= 0) {\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\t} else {\\n\\t\\tvar output = this.makeFilteredtransclude(filter, tooltip, template, style, classes, options);\\n\\t\\tif (output === undefined) {\\n\\t\\t\\tentry.impossible = true;\\n\\t\\t} else {\\n\\t\\t\\t// By copying over the ending newline of the original\\n\\t\\t\\t// text if present, thisrelink method thus works for\\n\\t\\t\\t// both the inline and block rule\\n\\t\\t\\tentry.output = output + utils.getEndingNewline(m[0]);\\n\\t\\t}\\n\\t\\tentry.filter = filter;\\n\\t}\\n\\tentry.template = template;\\n\\treturn entry;\\n};\\n\\nexports.makeFilteredtransclude = function(filter, tooltip, template, style, classes, options) {\\n\\tif (canBePretty(filter) && canBePrettyTemplate(template)) {\\n\\t\\treturn prettyList(filter, tooltip, template, style, classes);\\n\\t} else if (!options.noWidgets) {\\n\\t\\treturn widget(filter, tooltip, template, style, classes, options);\\n\\t}\\n\\treturn undefined;\\n};\\n\\nfunction prettyList(filter, tooltip, template, style, classes) {\\n\\tif (tooltip === undefined) {\\n\\t\\ttooltip = '';\\n\\t} else {\\n\\t\\ttooltip = \\\"|\\\" + tooltip;\\n\\t}\\n\\tif (template === undefined) {\\n\\t\\ttemplate = '';\\n\\t} else {\\n\\t\\ttemplate = \\\"||\\\" + template;\\n\\t}\\n\\tif (classes === undefined) {\\n\\t\\tclasses = '';\\n\\t} else {\\n\\t\\tclasses = \\\".\\\" + classes;\\n\\t}\\n\\tstyle = style || '';\\n\\treturn \\\"{{{\\\"+filter+tooltip+template+\\\"}}\\\"+style+\\\"}\\\"+classes;\\n};\\n\\n/** Returns a filtered transclude as a string of a widget.\\n */\\nfunction widget(filter, tooltip, template, style, classes, options) {\\n\\tvar cannotDo = false;\\n\\tif (classes !== undefined) {\\n\\t\\tclasses = classes.split('.').join(' ');\\n\\t}\\n\\tfunction wrap(name, value, treatAsTitle) {\\n\\t\\tif (!value) {\\n\\t\\t\\treturn '';\\n\\t\\t}\\n\\t\\tvar wrappedValue = utils.wrapAttributeValue(value);\\n\\t\\tif (wrappedValue === undefined) {\\n\\t\\t\\tif (!options.placeholder) {\\n\\t\\t\\t\\tcannotDo = true;\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\t\\t\\tvar category = treatAsTitle ? undefined : name;\\n\\t\\t\\twrappedValue = \\\"<<\\\"+options.placeholder.getPlaceholderFor(value,category,options)+\\\">>\\\";\\n\\t\\t}\\n\\t\\treturn \\\" \\\"+name+\\\"=\\\"+wrappedValue;\\n\\t};\\n\\tvar widget = [\\n\\t\\t\\\"<$list\\\",\\n\\t\\twrap(\\\"filter\\\", filter),\\n\\t\\twrap(\\\"tooltip\\\", tooltip),\\n\\t\\twrap(\\\"template\\\", template, true),\\n\\t\\twrap(\\\"style\\\", style),\\n\\t\\twrap(\\\"itemClass\\\", classes),\\n\\t\\t\\\"/>\\\"\\n\\t];\\n\\tif (cannotDo) {\\n\\t\\treturn undefined;\\n\\t}\\n\\treturn widget.join('');\\n};\\n\\nfunction canBePretty(filter) {\\n\\treturn filter.indexOf('|') < 0 && filter.indexOf('}}') < 0;\\n};\\n\\nfunction canBePrettyTemplate(template) {\\n\\treturn !template || (\\n\\t\\ttemplate.indexOf('|') < 0\\n\\t\\t&& template.indexOf('{') < 0\\n\\t\\t&& template.indexOf('}') < 0);\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/filteredtransclude.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/html.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nHandles replacement in attributes of widgets and html elements\\nThis is configurable to select exactly which attributes of which elements\\nshould be changed.\\n\\n<$link to=\\\"TiddlerTitle\\\" />\\n\\n\\\\*/\\n\\nvar utils = require(\\\"./utils.js\\\");\\nvar Rebuilder = require(\\\"$:/plugins/flibbles/relink/js/utils/rebuilder\\\");\\nvar settings = require('$:/plugins/flibbles/relink/js/settings.js');\\nvar refHandler = settings.getType('reference');\\nvar filterHandler = settings.getType('filter');\\nvar macrocall = require(\\\"./macrocall.js\\\");\\nvar EntryNode = require('$:/plugins/flibbles/relink/js/utils/entry');\\n\\nexports.name = \\\"html\\\";\\n\\nvar HtmlEntry = EntryNode.newCollection(\\\"html\\\");\\n\\nHtmlEntry.prototype.forEachChildReport = function(report, attribute, type) {\\n\\tvar rtn = attribute;\\n\\tif (type === \\\"filtered\\\") {\\n\\t\\trtn += \\\"={{{\\\" + report + \\\"}}}\\\";\\n\\t} else if (type === \\\"indirect\\\") {\\n\\t\\trtn += \\\"={{\\\" + report + \\\"}}\\\";\\n\\t} else if (type === \\\"macro\\\") {\\n\\t\\trtn += \\\"=\\\"+report;\\n\\t} else{\\n\\t\\t// must be string.\\n\\t\\tif (report.length > 0) {\\n\\t\\t\\trtn += '=\\\"' + report + '\\\"';\\n\\t\\t}\\n\\t}\\n\\treturn \\\"<\\\" + this.element + \\\" \\\" + rtn + \\\" />\\\";\\n};\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tvar managedElement = options.settings.getAttribute(this.nextTag.tag),\\n\\t\\tbuilder = new Rebuilder(text, this.nextTag.start);\\n\\tvar importFilterAttr;\\n\\tvar widgetEntry = new HtmlEntry();\\n\\twidgetEntry.attributes = Object.create(null);\\n\\twidgetEntry.element = this.nextTag.tag;\\n\\tfor (var attributeName in this.nextTag.attributes) {\\n\\t\\tvar attr = this.nextTag.attributes[attributeName];\\n\\t\\tvar nextEql = text.indexOf('=', attr.start);\\n\\t\\t// This is the rare case of changing tiddler\\n\\t\\t// \\\"true\\\" to something else when \\\"true\\\" is\\n\\t\\t// implicit, like <$link to /> We ignore those.\\n\\t\\tif (nextEql < 0 || nextEql > attr.end) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (this.nextTag.tag === \\\"$importvariables\\\" && attributeName === \\\"filter\\\") {\\n\\t\\t\\timportFilterAttr = attr;\\n\\t\\t}\\n\\t\\tvar oldLength, quotedValue = undefined, entry;\\n\\t\\tif (attr.type === \\\"string\\\") {\\n\\t\\t\\tvar handler = getAttributeHandler(this.nextTag, attributeName, options);\\n\\t\\t\\tif (!handler) {\\n\\t\\t\\t\\t// We don't manage this attribute. Bye.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tentry = handler.relink(attr.value, fromTitle, toTitle, options);\\n\\t\\t\\tif (entry === undefined) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (entry.output) {\\n\\t\\t\\t\\tvar quote = utils.determineQuote(text, attr);\\n\\t\\t\\t\\toldLength = attr.value.length + (quote.length * 2);\\n\\t\\t\\t\\tquotedValue = utils.wrapAttributeValue(entry.output,quote);\\n\\t\\t\\t\\tif (quotedValue === undefined) {\\n\\t\\t\\t\\t\\t// The value was unquotable. We need to make\\n\\t\\t\\t\\t\\t// a macro in order to replace it.\\n\\t\\t\\t\\t\\tif (!options.placeholder) {\\n\\t\\t\\t\\t\\t\\t// but we can't...\\n\\t\\t\\t\\t\\t\\tentry.impossible = true;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tvar value = options.placeholder.getPlaceholderFor(entry.output,handler.name,options)\\n\\t\\t\\t\\t\\t\\tquotedValue = \\\"<<\\\"+value+\\\">>\\\";\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if (attr.type === \\\"indirect\\\") {\\n\\t\\t\\tentry = refHandler.relinkInBraces(attr.textReference, fromTitle, toTitle, options);\\n\\t\\t\\tif (entry === undefined) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (entry.output) {\\n\\t\\t\\t\\t// +4 for '{{' and '}}'\\n\\t\\t\\t\\toldLength = attr.textReference.length + 4;\\n\\t\\t\\t\\tquotedValue = \\\"{{\\\"+entry.output+\\\"}}\\\";\\n\\t\\t\\t}\\n\\t\\t} else if (attr.type === \\\"filtered\\\") {\\n\\t\\t\\tentry = filterHandler.relinkInBraces(attr.filter, fromTitle, toTitle, options);\\n\\t\\t\\tif (entry === undefined) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (entry.output) {\\n\\t\\t\\t\\t// +6 for '{{{' and '}}}'\\n\\t\\t\\t\\toldLength = attr.filter.length + 6;\\n\\t\\t\\t\\tquotedValue = \\\"{{{\\\"+ entry.output +\\\"}}}\\\";\\n\\t\\t\\t}\\n\\t\\t} else if (attr.type === \\\"macro\\\") {\\n\\t\\t\\tvar macro = attr.value;\\n\\t\\t\\tentry = macrocall.relinkAttribute(macro, text, fromTitle, toTitle, options);\\n\\t\\t\\tif (entry === undefined) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (!entry.impossible) {\\n\\t\\t\\t\\t// already includes '<<' and '>>'\\n\\t\\t\\t\\toldLength = macro.end-macro.start;\\n\\t\\t\\t\\tquotedValue = entry.output;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twidgetEntry.addChild(entry, attributeName, attr.type);\\n\\t\\tif (quotedValue === undefined) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (this.nextTag.tag === \\\"$importvariables\\\" && attributeName === \\\"filter\\\") {\\n\\t\\t\\t// If this is an import variable filter, we gotta\\n\\t\\t\\t// remember this new value when we import lower down.\\n\\t\\t\\timportFilterAttr = quotedValue;\\n\\t\\t}\\n\\t\\t// We count backwards from the end to preserve whitespace\\n\\t\\tvar valueStart = attr.end - oldLength;\\n\\t\\tbuilder.add(quotedValue, valueStart, attr.end);\\n\\t}\\n\\tif (importFilterAttr) {\\n\\t\\tprocessImportFilter(importFilterAttr, options);\\n\\t}\\n\\tthis.parser.pos = this.nextTag.end;\\n\\tif (widgetEntry.hasChildren()) {\\n\\t\\twidgetEntry.output = builder.results(this.nextTag.end);\\n\\t\\treturn widgetEntry;\\n\\t}\\n\\treturn undefined;\\n};\\n\\n/** Returns the field handler for the given attribute of the given widget.\\n *  If this returns undefined, it means we don't handle it. So skip.\\n */\\nfunction getAttributeHandler(widget, attributeName, options) {\\n\\tif (widget.tag === \\\"$macrocall\\\") {\\n\\t\\tvar nameAttr = widget.attributes[\\\"$name\\\"];\\n\\t\\tif (nameAttr) {\\n\\t\\t\\tvar macro = options.settings.getMacro(nameAttr.value);\\n\\t\\t\\tif (macro) {\\n\\t\\t\\t\\treturn macro[attributeName];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else {\\n\\t\\tvar element = options.settings.getAttribute(widget.tag);\\n\\t\\tif (element) {\\n\\t\\t\\treturn element[attributeName];\\n\\t\\t}\\n\\t}\\n\\treturn undefined;\\n};\\n\\nfunction computeAttribute(attribute, options) {\\n\\tvar value;\\n\\tif(attribute.type === \\\"filtered\\\") {\\n\\t\\tvar parentWidget = options.settings.getVariableWidget();\\n\\t\\tvalue = options.wiki.filterTiddlers(attribute.filter,parentWidget)[0] || \\\"\\\";\\n\\t} else if(attribute.type === \\\"indirect\\\") {\\n\\t\\tvar parentWidget = options.settings.getVariableWidget();\\n\\t\\tvalue = options.wiki.getTextReference(attribute.textReference,\\\"\\\",parentWidget.variables.currentTiddler.value);\\n\\t} else if(attribute.type === \\\"macro\\\") {\\n\\t\\tvar parentWidget = options.settings.getVariableWidget();\\n\\t\\tvalue = parentWidget.getVariable(attribute.value.name,{params: attribute.value.params});\\n\\t} else { // String attribute\\n\\t\\tvalue = attribute.value;\\n\\t}\\n\\treturn value;\\n};\\n\\n// This processes a <$importvariables> filter attribute and adds any new\\n// variables to our parser.\\nfunction processImportFilter(importAttribute, options) {\\n\\tif (typeof importAttribute === \\\"string\\\") {\\n\\t\\t// It was changed. Reparse it. It'll be a quoted\\n\\t\\t// attribute value. Add a dummy attribute name.\\n\\t\\timportAttribute = $tw.utils.parseAttribute(\\\"p=\\\"+importAttribute, 0)\\n\\t}\\n\\tvar importFilter = computeAttribute(importAttribute, options);\\n\\toptions.settings.import(importFilter);\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/html.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/image.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nHandles replacement in wiki text inline rules, like,\\n\\n[img[tiddler.jpg]]\\n\\n[img width=23 height=24 [Description|tiddler.jpg]]\\n\\n\\\\*/\\n\\nvar Rebuilder = require(\\\"$:/plugins/flibbles/relink/js/utils/rebuilder\\\");\\nvar refHandler = require(\\\"$:/plugins/flibbles/relink/js/fieldtypes/reference\\\");\\nvar filterHandler = require(\\\"$:/plugins/flibbles/relink/js/settings\\\").getType('filter');\\nvar macrocall = require(\\\"./macrocall.js\\\");\\nvar utils = require(\\\"./utils.js\\\");\\nvar EntryNode = require('$:/plugins/flibbles/relink/js/utils/entry');\\n\\nexports.name = \\\"image\\\";\\n\\nvar ImageEntry = EntryNode.newCollection(\\\"image\\\");\\n\\nImageEntry.prototype.forEachChildReport = function(report, attribute, type) {\\n\\tvar value;\\n\\tif (attribute === \\\"source\\\") {\\n\\t\\tif (this.tooltip) {\\n\\t\\t\\tvalue = \\\"[img[\\\" + this.tooltip.value + \\\"]]\\\";\\n\\t\\t} else {\\n\\t\\t\\tvalue = \\\"[img[]]\\\";\\n\\t\\t}\\n\\t} else {\\n\\t\\tif (type === \\\"indirect\\\") {\\n\\t\\t\\tvalue = \\\"{{\\\" + report + \\\"}}\\\";\\n\\t\\t} else if (type === \\\"filtered\\\") {\\n\\t\\t\\tvalue = \\\"{{{\\\" + report + \\\"}}}\\\";\\n\\t\\t} else if (type === \\\"macro\\\") {\\n\\t\\t\\t// angle brackets already added...\\n\\t\\t\\tvalue = report;\\n\\t\\t}\\n\\t\\tvalue = \\\"[img \\\" + attribute + \\\"=\\\"+ value + \\\"]\\\";\\n\\t}\\n\\treturn value;\\n};\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tvar ptr = this.nextImage.start;\\n\\tvar builder = new Rebuilder(text, ptr);\\n\\tvar makeWidget = false;\\n\\tvar skipSource = false;\\n\\tvar imageEntry = new ImageEntry();\\n\\timageEntry.attributes = Object.create(null);\\n\\tif (this.nextImage.attributes.source.value === fromTitle && !canBePretty(toTitle, this.nextImage.attributes.tooltip)) {\\n\\t\\tif (!options.noWidgets && (utils.wrapAttributeValue(toTitle) || options.placeholder)) {\\n\\t\\t\\tmakeWidget = true;\\n\\t\\t\\tbuilder.add(\\\"<$image\\\", ptr, ptr+4);\\n\\t\\t} else {\\n\\t\\t\\t// We won't be able to make a placeholder to replace\\n\\t\\t\\t// the source attribute. We check now so we don't\\n\\t\\t\\t// prematurely convert into a widget.\\n\\t\\t\\t// Keep going in case other attributes need replacing.\\n\\t\\t\\tskipSource = true;\\n\\t\\t}\\n\\t}\\n\\tptr += 4; //[img\\n\\tvar inSource = false;\\n\\tfor (var attributeName in this.nextImage.attributes) {\\n\\t\\tvar attr = this.nextImage.attributes[attributeName];\\n\\t\\tif (attributeName === \\\"source\\\" || attributeName === \\\"tooltip\\\") {\\n\\t\\t\\tif (inSource) {\\n\\t\\t\\t\\tptr = text.indexOf('|', ptr);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tptr = text.indexOf('[', ptr);\\n\\t\\t\\t\\tinSource = true;\\n\\t\\t\\t}\\n\\t\\t\\tif (makeWidget) {\\n\\t\\t\\t\\tif (\\\" \\\\t\\\\n\\\".indexOf(text[ptr-1]) >= 0) {\\n\\t\\t\\t\\t\\tbuilder.add('', ptr, ptr+1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbuilder.add(' ', ptr, ptr+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tptr += 1;\\n\\t\\t}\\n\\t\\tif (attributeName === \\\"source\\\") {\\n\\t\\t\\tptr = text.indexOf(attr.value, ptr);\\n\\t\\t\\tif (attr.value === fromTitle) {\\n\\t\\t\\t\\tvar entry = {name: \\\"title\\\"};\\n\\t\\t\\t\\tif (makeWidget) {\\n\\t\\t\\t\\t\\tvar quotedValue = utils.wrapAttributeValue(toTitle);\\n\\t\\t\\t\\t\\tif (quotedValue === undefined) {\\n\\t\\t\\t\\t\\t\\tvar key = options.placeholder.getPlaceholderFor(toTitle, undefined, options);\\n\\t\\t\\t\\t\\t\\tbuilder.add(\\\"source=<<\\\"+key+\\\">>\\\", ptr, ptr+fromTitle.length);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbuilder.add(\\\"source=\\\"+quotedValue, ptr, ptr+fromTitle.length);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (!skipSource) {\\n\\t\\t\\t\\t\\tbuilder.add(toTitle, ptr, ptr+fromTitle.length);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tentry.impossible = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\timageEntry.addChild(entry, attributeName, \\\"string\\\");\\n\\t\\t\\t}\\n\\t\\t\\tptr = text.indexOf(']]', ptr);\\n\\t\\t\\tif (makeWidget) {\\n\\t\\t\\t\\tbuilder.add(\\\"/>\\\", ptr, ptr+2);\\n\\t\\t\\t}\\n\\t\\t\\tptr += 2;\\n\\t\\t} else if (attributeName === \\\"tooltip\\\") {\\n\\t\\t\\tif (makeWidget) {\\n\\t\\t\\t\\tptr = text.indexOf(attr.value, ptr);\\n\\t\\t\\t\\tvar quotedValue = utils.wrapAttributeValue(attr.value);\\n\\t\\t\\t\\tbuilder.add(\\\"tooltip=\\\"+quotedValue, ptr, ptr+attr.value.length);\\n\\t\\t\\t}\\n\\t\\t\\timageEntry.tooltip = this.nextImage.attributes.tooltip;\\n\\t\\t} else {\\n\\t\\t\\tptr = relinkAttribute(attr, builder, fromTitle, toTitle, imageEntry, options);\\n\\t\\t}\\n\\t}\\n\\tthis.parser.pos = ptr;\\n\\tif (imageEntry.hasChildren()) {\\n\\t\\timageEntry.output = builder.results(ptr);\\n\\t\\treturn imageEntry;\\n\\t}\\n\\treturn undefined;\\n};\\n\\nfunction relinkAttribute(attribute, builder, fromTitle, toTitle, entry, options) {\\n\\tvar text = builder.text;\\n\\tvar ptr = text.indexOf(attribute.name, attribute.start);\\n\\tvar end;\\n\\tptr += attribute.name.length;\\n\\tptr = text.indexOf('=', ptr);\\n\\tif (attribute.type === \\\"string\\\") {\\n\\t\\tptr = text.indexOf(attribute.value, ptr)\\n\\t\\tvar quote = utils.determineQuote(text, attribute);\\n\\t\\t// ignore first quote. We already passed it\\n\\t\\tend = ptr + quote.length + attribute.value.length;\\n\\t} else if (attribute.type === \\\"indirect\\\") {\\n\\t\\tptr = text.indexOf('{{', ptr);\\n\\t\\tvar end = ptr + attribute.textReference.length + 4;\\n\\t\\tvar ref = refHandler.relinkInBraces(attribute.textReference, fromTitle, toTitle, options);\\n\\t\\tif (ref) {\\n\\t\\t\\tentry.addChild(ref, attribute.name, \\\"indirect\\\");\\n\\t\\t\\tif (ref.output) {\\n\\t\\t\\t\\tbuilder.add(\\\"{{\\\"+ref.output+\\\"}}\\\", ptr, end);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else if (attribute.type === \\\"filtered\\\") {\\n\\t\\tptr = text.indexOf('{{{', ptr);\\n\\t\\tvar end = ptr + attribute.filter.length + 6;\\n\\t\\tvar filter = filterHandler.relinkInBraces(attribute.filter, fromTitle, toTitle, options);\\n\\t\\tif (filter !== undefined) {\\n\\t\\t\\tentry.addChild(filter, attribute.name, \\\"filtered\\\");\\n\\t\\t\\tif (filter.output) {\\n\\t\\t\\t\\tvar quoted = \\\"{{{\\\"+filter.output+\\\"}}}\\\";\\n\\t\\t\\t\\tbuilder.add(quoted, ptr, end);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else if (attribute.type === \\\"macro\\\") {\\n\\t\\tptr = text.indexOf(\\\"<<\\\", ptr);\\n\\t\\tvar end = attribute.value.end;\\n\\t\\tvar macro = attribute.value;\\n\\t\\toldValue = attribute.value;\\n\\t\\tvar macroEntry = macrocall.relinkAttribute(macro, text, fromTitle, toTitle, options);\\n\\t\\tif (macroEntry !== undefined) {\\n\\t\\t\\tentry.addChild(macroEntry, attribute.name, \\\"macro\\\");\\n\\t\\t\\tif (macroEntry.output) {\\n\\t\\t\\t\\tbuilder.add(macroEntry.output, ptr, end);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn end;\\n};\\n\\nfunction canBePretty(title, tooltip) {\\n\\treturn title.indexOf(']') < 0 && (tooltip || title.indexOf('|') < 0);\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/image.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/import.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nHandles import pragmas\\n\\n\\\\import [tag[MyTiddler]]\\n\\\\*/\\n\\nvar settings = require(\\\"$:/plugins/flibbles/relink/js/settings.js\\\");\\nvar filterRelinker = settings.getType('filter');\\n\\nexports.name = \\\"import\\\";\\n\\nfunction ImportEntry(filterEntry) {\\n\\tthis.filter = filterEntry;\\n};\\nImportEntry.prototype.name = \\\"import\\\";\\nImportEntry.prototype.eachChild = function(block) { return block(this.filter);};\\nImportEntry.prototype.report = function() {\\n\\treturn this.filter.report().map(function(report) {\\n\\t\\tif (report.length > 0) {\\n\\t\\t\\treturn \\\"\\\\\\\\import \\\" + report;\\n\\t\\t} else {\\n\\t\\t\\treturn \\\"\\\\\\\\import\\\";\\n\\t\\t}\\n\\t});\\n};\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\t// In this one case, I'll let the parser parse out the filter and move\\n\\t// the ptr.\\n\\tvar start = this.matchRegExp.lastIndex;\\n\\tvar parseTree = this.parse();\\n\\tvar filter = parseTree[0].attributes.filter.value;\\n\\tvar entry = undefined;\\n\\tvar filterEntry = filterRelinker.relink(filter, fromTitle, toTitle, options);\\n\\tif (filterEntry !== undefined) {\\n\\t\\tentry = new ImportEntry(filterEntry);\\n\\t\\tvar newline = text.substring(start+filter.length, this.parser.pos);\\n\\t\\tif (filterEntry.output) {\\n\\t\\t\\tfilter = filterEntry.output;\\n\\t\\t\\tentry.output = \\\"\\\\\\\\import \\\" + filter + newline;\\n\\t\\t}\\n\\t}\\n\\n\\t// Before we go, we need to actually import the variables\\n\\t// it's calling for, and any /relink pragma\\n\\toptions.settings.import(filter);\\n\\n\\treturn entry;\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/import.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/macrocall.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nHandles macro calls.\\n\\n<<myMacro '[[MyFilter]]' 'myTitle'>>\\n\\n\\\\*/\\n\\nvar utils = require(\\\"./utils.js\\\");\\nvar Rebuilder = require(\\\"$:/plugins/flibbles/relink/js/utils/rebuilder\\\");\\nvar settings = require('$:/plugins/flibbles/relink/js/settings.js');\\nvar EntryNode = require('$:/plugins/flibbles/relink/js/utils/entry');\\n\\nexports.name = [\\\"macrocallinline\\\", \\\"macrocallblock\\\"];\\n\\n// Error thrown when a macro's definition is needed, but can't be found.\\nfunction CannotFindMacroDef() {};\\nCannotFindMacroDef.prototype.impossible = true;\\nCannotFindMacroDef.prototype.name = \\\"macroparam\\\";\\n// Failed relinks due to missing definitions aren't reported for now.\\n// I may want to do something special later on.\\nCannotFindMacroDef.prototype.report = function() { return []; };\\n\\nvar MacrocallEntry = EntryNode.newCollection(\\\"macrocall\\\");\\n\\nMacrocallEntry.prototype.forEachChildReport = function(report, parameter, type) {\\n\\tvar rtn;\\n\\tif (report.length > 0) {\\n\\t\\trtn = parameter + ': \\\"' + report + '\\\"';\\n\\t} else {\\n\\t\\trtn = parameter;\\n\\t}\\n\\treturn \\\"<<\\\" + this.macro + \\\" \\\" + rtn + \\\">>\\\";\\n};\\n\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\t// Get all the details of the match\\n\\tvar macroName = this.match[1],\\n\\t\\tparamString = this.match[2],\\n\\t\\tmacroText = this.match[0];\\n\\t// Move past the macro call\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\tif (!options.settings.survey(macroText, fromTitle, options)) {\\n\\t\\treturn undefined;\\n\\t}\\n\\tvar start = this.matchRegExp.lastIndex - this.match[0].length;\\n\\tvar managedMacro = options.settings.getMacro(macroName);\\n\\tif (!managedMacro) {\\n\\t\\t// We don't manage this macro. Bye.\\n\\t\\treturn undefined;\\n\\t}\\n\\tvar offset = macroName.length+2;\\n\\toffset = $tw.utils.skipWhiteSpace(macroText, offset);\\n\\tvar params = parseParams(paramString, offset+start);\\n\\tvar macroInfo = {\\n\\t\\tname: macroName,\\n\\t\\tstart: start,\\n\\t\\tend: this.matchRegExp.lastIndex,\\n\\t\\tparams: params\\n\\t};\\n\\tvar mayBeWidget = !options.noWidgets;\\n\\tvar names = getParamNames(macroInfo.name, macroInfo.params, options);\\n\\tif (names === undefined) {\\n\\t\\t// Needed the definition, and couldn't find it. So if a single\\n\\t\\t// parameter needs to placeholder, just fail.\\n\\t\\tmayBeWidget = false;\\n\\t}\\n\\tvar entry = relinkMacroInvocation(macroInfo, text, fromTitle, toTitle, mayBeWidget, options);\\n\\tif (entry && entry.output) {\\n\\t\\tentry.output =macroToString(entry.output, text, names, options);\\n\\t}\\n\\treturn entry;\\n};\\n\\n/** Relinks macros that occur as attributes, like <$element attr=<<...>> />\\n *  Processes the same, except it can't downgrade into a widget if the title\\n *  is complicated.\\n */\\nexports.relinkAttribute = function(macro, text, fromTitle, toTitle, options) {\\n\\tvar entry = relinkMacroInvocation(macro, text, fromTitle, toTitle, false, options);\\n\\tif (entry && entry.output) {\\n\\t\\tentry.output = macroToStringMacro(entry.output, text, options);\\n\\t}\\n\\treturn entry;\\n};\\n\\n/**Processes the given macro,\\n * macro: {name:, params:, start:, end:}\\n * each parameters: {name:, end:, value:}\\n * Macro invocation returned is the same, but relinked, and may have new keys:\\n * parameters: {type: macro, start:, newValue: (quoted replacement value)}\\n * Output of the returned entry isn't a string, but a macro object. It needs\\n * to be converted.\\n */\\nfunction relinkMacroInvocation(macro, text, fromTitle, toTitle, mayBeWidget, options) {\\n\\tvar managedMacro = options.settings.getMacro(macro.name);\\n\\tvar modified = false;\\n\\tif (!managedMacro) {\\n\\t\\t// We don't manage this macro. Bye.\\n\\t\\treturn undefined;\\n\\t}\\n\\tif (macro.params.every(function(p) {\\n\\t\\treturn !options.settings.survey(p.value, fromTitle, options);\\n\\t})) {\\n\\t\\t// We cut early if the fromTitle doesn't even appear\\n\\t\\t// anywhere in the title. This is to avoid any headache\\n\\t\\t// about finding macro definitions (and any resulting\\n\\t\\t// exceptions if there isn't even a title to replace.\\n\\t\\treturn undefined;\\n\\t}\\n\\tvar outMacro = $tw.utils.extend({}, macro);\\n\\tvar macroEntry = new MacrocallEntry();\\n\\tmacroEntry.parameters = Object.create(null);\\n\\toutMacro.params = macro.params.slice();\\n\\tfor (var managedArg in managedMacro) {\\n\\t\\tvar index;\\n\\t\\ttry {\\n\\t\\t\\tindex = getParamIndexWithinMacrocall(macro.name, managedArg, macro.params, options);\\n\\t\\t} catch (e) {\\n\\t\\t\\tif (e instanceof CannotFindMacroDef) {\\n\\t\\t\\t\\tmacroEntry.addChild(e);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (index < 0) {\\n\\t\\t\\t// this arg either was not supplied, or we can't find\\n\\t\\t\\t// the definition, so we can't tie it to an anonymous\\n\\t\\t\\t// argument. Either way, move on to the next.\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tvar param = macro.params[index];\\n\\t\\tvar handler = managedMacro[managedArg];\\n\\t\\tvar entry = handler.relink(param.value, fromTitle, toTitle, options);\\n\\t\\tif (entry === undefined) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t// Macro parameters can only be string parameters, not\\n\\t\\t// indirect, or macro, or filtered\\n\\t\\tmacroEntry.addChild(entry, managedArg, \\\"string\\\");\\n\\t\\tif (!entry.output) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tvar quote = utils.determineQuote(text, param);\\n\\t\\tvar quoted = utils.wrapParameterValue(entry.output, quote);\\n\\t\\tvar newParam = $tw.utils.extend({}, param);\\n\\t\\tif (quoted === undefined) {\\n\\t\\t\\tif (!mayBeWidget || !options.placeholder) {\\n\\t\\t\\t\\tentry.impossible = true;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tvar ph = options.placeholder.getPlaceholderFor(entry.output,handler.name, options);\\n\\t\\t\\tnewParam.newValue = \\\"<<\\\"+ph+\\\">>\\\";\\n\\t\\t\\tnewParam.type = \\\"macro\\\";\\n\\t\\t} else {\\n\\t\\t\\tnewParam.start = newParam.end - (newParam.value.length + (quote.length*2));\\n\\t\\t\\tnewParam.value = entry.output;\\n\\t\\t\\tnewParam.newValue = quoted;\\n\\t\\t}\\n\\t\\toutMacro.params[index] = newParam;\\n\\t\\tmodified = true;\\n\\t}\\n\\tif (macroEntry.hasChildren()) {\\n\\t\\tmacroEntry.macro = macro.name;\\n\\t\\tif (modified) {\\n\\t\\t\\tmacroEntry.output = outMacro;\\n\\t\\t}\\n\\t\\treturn macroEntry;\\n\\t}\\n\\treturn undefined;\\n};\\n\\nfunction mustBeAWidget(macro) {\\n\\tfor (var i = 0; i < macro.params.length; i++) {\\n\\t\\tif (macro.params[i].type === \\\"macro\\\") {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false\\n};\\n\\n/**Given a macro object ({name:, params:, start: end:}), and the text where\\n * it was parsed from, returns a new macro that maintains any syntactic\\n * structuring.\\n */\\nfunction macroToString(macro, text, names, options) {\\n\\tif (mustBeAWidget(macro)) {\\n\\t\\tvar attrs = [];\\n\\t\\tfor (var i = 0; i < macro.params.length; i++) {\\n\\t\\t\\tvar p = macro.params[i];\\n\\t\\t\\tvar val;\\n\\t\\t\\tif (p.newValue) {\\n\\t\\t\\t\\tval = p.newValue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tval = utils.wrapAttributeValue(p.value);\\n\\t\\t\\t}\\n\\t\\t\\tattrs.push(\\\" \\\"+names[i]+\\\"=\\\"+val);\\n\\t\\t}\\n\\t\\treturn \\\"<$macrocall $name=\\\"+utils.wrapAttributeValue(macro.name)+attrs.join('')+\\\"/>\\\";\\n\\t} else {\\n\\t\\treturn macroToStringMacro(macro, text, options);\\n\\t}\\n};\\n\\nfunction macroToStringMacro(macro, text, options) {\\n\\tvar builder = new Rebuilder(text, macro.start);\\n\\tfor (var i = 0; i < macro.params.length; i++) {\\n\\t\\tvar param = macro.params[i];\\n\\t\\tif (param.newValue) {\\n\\t\\t\\tbuilder.add(param.newValue, param.start, param.end);\\n\\t\\t}\\n\\t}\\n\\treturn builder.results(macro.end);\\n};\\n\\n/** Returns -1 if param definitely isn't in macrocall.\\n */\\nfunction getParamIndexWithinMacrocall(macroName, param, params, options) {\\n\\tvar index, i, anonsExist = false;\\n\\tfor (i = 0; i < params.length; i++) {\\n\\t\\tvar name = params[i].name;\\n\\t\\tif (name === param) {\\n\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\tif (name === undefined) {\\n\\t\\t\\tanonsExist = true;\\n\\t\\t}\\n\\t}\\n\\tif (!anonsExist) {\\n\\t\\t// If no anonymous parameters are present, and we didn't find\\n\\t\\t// it among the named ones, it must not be there.\\n\\t\\treturn -1;\\n\\t}\\n\\tvar expectedIndex = indexOfParameterDef(macroName, param, options);\\n\\t// We've got to skip over all the named parameter instances.\\n\\tif (expectedIndex >= 0) {\\n\\t\\tvar anonI = 0;\\n\\t\\tfor (i = 0; i < params.length; i++) {\\n\\t\\t\\tif (params[i].name === undefined) {\\n\\t\\t\\t\\tif (anonI === expectedIndex) {\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tanonI++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar indexOfOther = indexOfParameterDef(macroName, params[i].name, options);\\n\\t\\t\\t\\tif (indexOfOther < expectedIndex) {\\n\\t\\t\\t\\t\\tanonI++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n};\\n\\n// Looks up the definition of a macro, and figures out what the expected index\\n// is for the given parameter.\\nfunction indexOfParameterDef(macroName, paramName, options) {\\n\\tvar def = options.settings.getMacroDefinition(macroName);\\n\\tif (def === undefined) {\\n\\t\\tthrow new CannotFindMacroDef();\\n\\t}\\n\\tvar params = def.params || [];\\n\\tfor (var i = 0; i < params.length; i++) {\\n\\t\\tif (params[i].name === paramName) {\\n\\t\\t\\treturn i;\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n};\\n\\nfunction getParamNames(macroName, params, options) {\\n\\tvar used = Object.create(null);\\n\\tvar rtn = new Array(params.length);\\n\\tvar anonsExist = false;\\n\\tvar i;\\n\\tfor (i = 0; i < params.length; i++) {\\n\\t\\tvar name = params[i].name;\\n\\t\\tif (name) {\\n\\t\\t\\trtn[i] = name;\\n\\t\\t\\tused[name] = true;\\n\\t\\t} else {\\n\\t\\t\\tanonsExist = true;\\n\\t\\t}\\n\\t}\\n\\tif (anonsExist) {\\n\\t\\tvar def = options.settings.getMacroDefinition(macroName);\\n\\t\\tif (def === undefined) {\\n\\t\\t\\t// If there are anonymous parameters, and we can't\\n\\t\\t\\t// find the definition, then we can't hope to create\\n\\t\\t\\t// a widget.\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\t\\tvar defParams = def.params || [];\\n\\t\\tvar defPtr = 0;\\n\\t\\tfor (i = 0; i < params.length; i++) {\\n\\t\\t\\tif (rtn[i] === undefined) {\\n\\t\\t\\t\\twhile(defPtr < defParams.length && used[defParams[defPtr].name]) {\\n\\t\\t\\t\\t\\tdefPtr++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (defPtr >= defParams.length) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trtn[i] = defParams[defPtr].name;\\n\\t\\t\\t\\tused[defParams[defPtr].name] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn rtn;\\n};\\n\\nfunction parseParams(paramString, pos) {\\n\\tvar params = [],\\n\\t\\treParam = /\\\\s*(?:([A-Za-z0-9\\\\-_]+)\\\\s*:)?(?:\\\\s*(?:\\\"\\\"\\\"([\\\\s\\\\S]*?)\\\"\\\"\\\"|\\\"([^\\\"]*)\\\"|'([^']*)'|\\\\[\\\\[([^\\\\]]*)\\\\]\\\\]|([^\\\"'\\\\s]+)))/mg,\\n\\t\\tparamMatch = reParam.exec(paramString);\\n\\twhile(paramMatch) {\\n\\t\\t// Process this parameter\\n\\t\\tvar paramInfo = {\\n\\t\\t\\tvalue: paramMatch[2] || paramMatch[3] || paramMatch[4] || paramMatch[5] || paramMatch[6]\\n\\t\\t};\\n\\t\\tif(paramMatch[1]) {\\n\\t\\t\\tparamInfo.name = paramMatch[1];\\n\\t\\t}\\n\\t\\t//paramInfo.start = pos;\\n\\t\\tparamInfo.end = reParam.lastIndex + pos;\\n\\t\\tparams.push(paramInfo);\\n\\t\\t// Find the next match\\n\\t\\tparamMatch = reParam.exec(paramString);\\n\\t}\\n\\treturn params;\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/macrocall.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/macrodef.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nHandles pragma macro definitions. Except we only update placeholder macros\\nthat we may have previously install.\\n\\n\\\\define relink-?() Tough title\\n\\n\\\\*/\\n\\nvar settings = require(\\\"$:/plugins/flibbles/relink/js/settings\\\");\\n\\nexports.name = \\\"macrodef\\\";\\n\\nfunction MacrodefEntry(macroName, bodyEntry) {\\n\\tthis.macro = macroName;\\n\\tthis.body = bodyEntry;\\n};\\nMacrodefEntry.prototype.name = \\\"macrodef\\\";\\nMacrodefEntry.prototype.eachChild = function(block) { return block(this.body);};\\nMacrodefEntry.prototype.report = function() {\\n\\tvar macroStr = \\\"\\\\\\\\define \\\" + this.macro + \\\"()\\\";\\n\\tif (this.body.report) {\\n\\t\\treturn this.body.report().map(function(report) {\\n\\t\\t\\treturn macroStr + \\\" \\\" + report;\\n\\t\\t});\\n\\t} else {\\n\\t\\treturn [macroStr];\\n\\t}\\n};\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tvar setParseTreeNode = this.parse(),\\n\\t\\tmacroEntry,\\n\\t\\tm = this.match,\\n\\t\\twhitespace;\\n\\toptions.settings.addMacroDefinition(setParseTreeNode[0]);\\n\\t// Parse set the pos pointer, but we don't want to skip the macro body.\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\t// m[3] means it's a multiline macrodef\\n\\tif (m[3]) {\\n\\t\\tvalueRegExp = /\\\\r?\\\\n\\\\\\\\end[^\\\\S\\\\n\\\\r]*(?:\\\\r?\\\\n|$)/mg;\\n\\t\\twhitespace = '';\\n\\t} else {\\n\\t\\tvar newPos = $tw.utils.skipWhiteSpace(text, this.parser.pos);\\n\\t\\tvalueRegExp = /(?:\\\\r?\\\\n|$)/mg;\\n\\t\\twhitespace = text.substring(this.parser.pos, newPos);\\n\\t\\tthis.parser.pos = newPos;\\n\\t}\\n\\tvar valueRegExp;\\n\\tvalueRegExp.lastIndex = this.parser.pos;\\n\\tvar match = valueRegExp.exec(text);\\n\\tif (match) {\\n\\t\\tvar value = text.substring(this.parser.pos, match.index),\\n\\t\\t\\tplaceholder = /^relink-(?:(\\\\w+)-)?(\\\\d+)$/.exec(m[1]),\\n\\t\\t// normal macro or special placeholder?\\n\\t\\t\\ttype = (placeholder && m[2] === '')? placeholder[1] || 'title' : 'wikitext',\\n\\t\\t\\thandler = settings.getType(type);\\n\\t\\tif (handler) {\\n\\t\\t\\tvar entry = handler.relink(value, fromTitle, toTitle, options);\\n\\t\\t}\\n\\t\\tif (entry !== undefined) {\\n\\t\\t\\tmacroEntry = new MacrodefEntry(m[1], entry);\\n\\t\\t\\tif (entry.output) {\\n\\t\\t\\t\\tmacroEntry.output = m[0] + whitespace + entry.output + match[0];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.parser.pos = match.index + match[0].length;\\n\\t}\\n\\treturn macroEntry;\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/macrodef.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/prettylink.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nHandles replacement in wiki text inline rules, like,\\n\\n[[Introduction]]\\n\\n[[link description|TiddlerTitle]]\\n\\n\\\\*/\\n\\nvar utils = require(\\\"./utils.js\\\");\\n\\nfunction PrettyLinkEntry() {};\\nPrettyLinkEntry.prototype.name = \\\"prettylink\\\";\\nPrettyLinkEntry.prototype.report = function() {\\n\\treturn [\\\"[[\\\" + (this.caption || this.link) + \\\"]]\\\"];\\n};\\n\\nexports.name = \\\"prettylink\\\";\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\tvar caption, m = this.match;\\n\\tif (m[2] === fromTitle) {\\n\\t\\t// format is [[caption|MyTiddler]]\\n\\t\\tcaption = m[1];\\n\\t} else if (m[2] !== undefined || m[1] !== fromTitle) {\\n\\t\\t// format is [[MyTiddler]], and it doesn't match\\n\\t\\treturn undefined;\\n\\t}\\n\\tvar entry = new PrettyLinkEntry();\\n\\tentry.caption = caption;\\n\\tentry.link = toTitle;\\n\\tentry.output = this.makeLink(toTitle, caption, options);\\n\\tif (entry.output === undefined) {\\n\\t\\tentry.impossible = true;\\n\\t}\\n\\treturn entry;\\n};\\n\\nexports.makeLink = function(tiddler, caption, options) {\\n\\tvar output, quoted;\\n\\tif (!options.noPrettylinks && this.canBePretty(tiddler, !!caption)) {\\n\\t\\toutput = prettyLink(tiddler, caption);\\n\\t} else if (options.noWidgets) {\\n\\t\\t// We aren't allowed to make widgets. Gotta fail.\\n\\t\\toutput = undefined;\\n\\t} else if (caption === undefined) {\\n\\t\\tif (exports.shorthandSupported(options)) {\\n\\t\\t\\tquoted = utils.wrapAttributeValue(tiddler);\\n\\t\\t\\tif (!quoted) {\\n\\t\\t\\t\\tif (!options.placeholder) {\\n\\t\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tquoted = \\\"<<\\\" + options.placeholder.getPlaceholderFor(tiddler,undefined,options) + \\\">>\\\";\\n\\t\\t\\t}\\n\\t\\t\\toutput = \\\"<$link to=\\\"+quoted+\\\"/>\\\";\\n\\t\\t} else {\\n\\t\\t\\t// If we don't have a caption, we must resort to\\n\\t\\t\\t// placeholders anyway to prevent link/caption desync\\n\\t\\t\\t// from later relinks.\\n\\t\\t\\t// It doesn't matter whether the tiddler is quotable.\\n\\t\\t\\tif (options.placeholder) {\\n\\t\\t\\t\\tvar ph = options.placeholder.getPlaceholderFor(tiddler, undefined, options);\\n\\t\\t\\t\\toutput = \\\"<$link to=<<\\\"+ph+\\\">>><$text text=<<\\\"+ph+\\\">>/></$link>\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else if (quoted = utils.wrapAttributeValue(tiddler)) {\\n\\t\\tvar safeCaption = sanitizeCaption(caption, options);\\n\\t\\tif (safeCaption !== undefined) {\\n\\t\\t\\toutput = \\\"<$link to=\\\"+quoted+\\\">\\\"+safeCaption+\\\"</$link>\\\";\\n\\t\\t}\\n\\t} else if (options.placeholder) {\\n\\t\\tvar ph = options.placeholder.getPlaceholderFor(tiddler, undefined, options);\\n\\t\\t// We don't test if caption is undefined here, because it\\n\\t\\t// never will be. options.placeholder exists.\\n\\t\\tvar safeCaption = sanitizeCaption(caption, options);\\n\\t\\toutput = \\\"<$link to=<<\\\"+ph+\\\">>>\\\"+safeCaption+\\\"</$link>\\\";\\n\\t}\\n\\treturn output;\\n};\\n\\n/**Return true if value can be used inside a prettylink.\\n */\\nexports.canBePretty = function(value, customCaption) {\\n\\treturn value.indexOf(\\\"]]\\\") < 0 && value[value.length-1] !== ']' && (customCaption || value.indexOf('|') < 0);\\n};\\n\\n/**In version 5.1.20, Tiddlywiki made it so <$link to\\\"something\\\" /> would\\n * use \\\"something\\\" as a caption. This is preferable. However, Relink works\\n * going back to 5.1.14, so we need to have different handling for both\\n * cases.\\n */\\nvar _supported;\\nexports.shorthandSupported = function(options) {\\n\\tif (_supported === undefined) {\\n\\t\\tvar test = options.wiki.renderText(\\\"text/plain\\\", \\\"text/vnd.tiddlywiki\\\", \\\"<$link to=test/>\\\");\\n\\t\\t_supported = (test === \\\"test\\\");\\n\\t}\\n\\treturn _supported;\\n};\\n\\nfunction sanitizeCaption(caption, options) {\\n\\tvar plaintext = options.wiki.renderText(\\\"text/plain\\\", \\\"text/vnd.tiddlywiki\\\", caption);\\n\\tif (plaintext === caption && caption.indexOf(\\\"</$link>\\\") <= 0) {\\n\\t\\treturn caption;\\n\\t} else {\\n\\t\\tvar wrapped = utils.wrapAttributeValue(caption);\\n\\t\\tif (wrapped) {\\n\\t\\t\\treturn \\\"<$text text=\\\"+wrapped+\\\"/>\\\";\\n\\t\\t} else if (options.placeholder) {\\n\\t\\t\\tvar ph = options.placeholder.getPlaceholderFor(caption, \\\"caption\\\", options);\\n\\t\\t\\treturn \\\"<$text text=<<\\\"+ph+\\\">>/>\\\";\\n\\t\\t} else {\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\t}\\n};\\n\\nfunction prettyLink(title, caption) {\\n\\tif (caption) {\\n\\t\\treturn \\\"[[\\\" + caption + \\\"|\\\" + title + \\\"]]\\\";\\n\\t} else {\\n\\t\\treturn \\\"[[\\\" + title + \\\"]]\\\";\\n\\t}\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/prettylink.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/relink.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: wikirule\\n\\nThis defines the \\\\relink inline pragma used to locally declare\\nrelink rules for macros.\\n\\nIt takes care of providing its own relink and report rules.\\n\\n\\\\*/\\n\\nvar settings = require('$:/plugins/flibbles/relink/js/settings.js');\\nvar language = require('$:/plugins/flibbles/relink/js/language.js');\\n\\nexports.name = \\\"relink\\\";\\nexports.types = {pragma: true};\\n\\nexports.init = function(parser) {\\n\\tthis.parser = parser;\\n\\tthis.matchRegExp = /^\\\\\\\\relink[^\\\\S\\\\n]+([^(\\\\s]+)([^\\\\r\\\\n]*)(\\\\r?\\\\n)?/mg;\\n};\\n\\n/**This makes the widget that the macro library will later parse to determine\\n * new macro relink state.\\n *\\n * It's a <$set> widget so it can appear BEFORE \\\\define pragma and not\\n * prevent that pragma from being scooped up by importvariables.\\n * (importvariables stops scooping as soon as it sees something besides $set) */\\nexports.parse = function() {\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\tvar macroName;\\n\\tvar macroParams = Object.create(null);\\n\\tvar error = undefined;\\n\\tvar rtn = [];\\n\\tvar self = this;\\n\\tthis.interpretSettings(function(macro, parameter, type) {\\n\\t\\tmacroName = macro;\\n\\t\\tif (type && !settings.getType(type)) {\\n\\t\\t\\terror = language.getString(\\\"Error/UnrecognizedType\\\",\\n\\t\\t\\t\\t{variables: {type: type}, wiki: self.parser.wiki});\\n\\t\\t}\\n\\t\\tmacroParams[parameter] = type;\\n\\t});\\n\\t// If no macroname. Return nothing, this rule will be ignored by parsers\\n\\tif (macroName) {\\n\\t\\tvar relink = Object.create(null);\\n\\t\\trelink[macroName] = macroParams;\\n\\t\\trtn.push({\\n\\t\\t\\ttype: \\\"set\\\",\\n\\t\\t\\tattributes: {\\n\\t\\t\\t\\tname: {type: \\\"string\\\", value: \\\"\\\"}\\n\\t\\t\\t},\\n\\t\\t\\tchildren: [],\\n\\t\\t\\tisMacroDefinition: true,\\n\\t\\t\\trelink: relink});\\n\\t}\\n\\tif (error) {\\n\\t\\trtn.push({\\n\\t\\t\\ttype: \\\"element\\\", tag: \\\"span\\\", attributes: {\\n\\t\\t\\t\\t\\\"class\\\": {\\n\\t\\t\\t\\t\\ttype: \\\"string\\\",\\n\\t\\t\\t\\t\\tvalue: \\\"tc-error tc-relink-error\\\"\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, children: [\\n\\t\\t\\t\\t{type: \\\"text\\\", text: error}\\n\\t\\t\\t]});\\n\\t}\\n\\treturn rtn;\\n};\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\tvar self = this;\\n\\tthis.interpretSettings(function(macro, parameter, type) {\\n\\t\\toptions.settings.addSetting(macro, parameter, type, options.currentTiddler);\\n\\t});\\n\\t// Return nothing, because this rule is ignored by the parser\\n\\treturn undefined;\\n};\\n\\nexports.interpretSettings = function(block) {\\n\\tvar paramString = this.match[2];\\n\\tif (paramString !== \\\"\\\") {\\n\\t\\tvar macro = this.match[1];\\n\\t\\tvar reParam = /\\\\s*([A-Za-z0-9\\\\-_]+)(?:\\\\s*:\\\\s*([^\\\\s]+))?/mg;\\n\\t\\tvar paramMatch = reParam.exec(paramString);\\n\\t\\twhile (paramMatch) {\\n\\t\\t\\tvar parameter = paramMatch[1];\\n\\t\\t\\tvar type = paramMatch[2];\\n\\t\\t\\tblock(macro, parameter, type);\\n\\t\\t\\tparamMatch = reParam.exec(paramString);\\n\\t\\t}\\n\\t}\\n};\\n\",\n            \"module-type\": \"wikirule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/relink.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/rules.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nParses and acknowledges any pragma rules a tiddler has.\\n\\n\\\\rules except html wikilink\\n\\n\\\\*/\\n\\nexports.name = \\\"rules\\\";\\n\\n/**This is all we have to do. The rules rule doesn't parse. It just amends\\n * the rules, which is exactly what I want it to do too.\\n * It also takes care of moving the pos pointer forward.\\n */\\nexports.relink = function() {\\n\\tthis.parse();\\n\\treturn undefined;\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/rules.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/syslink.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nHandles sys links\\n\\n$:/sys/link\\n\\nbut not:\\n\\n~$:/sys/link\\n\\n\\\\*/\\n\\nvar utils = require(\\\"./utils.js\\\");\\nvar prettylink = require('$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/prettylink.js');\\n\\nexports.name = \\\"syslink\\\";\\n\\nfunction SyslinkEntry() {};\\nSyslinkEntry.prototype.name = \\\"syslink\\\";\\nSyslinkEntry.prototype.report = function() {\\n\\treturn [\\\"~\\\" + this.link];\\n};\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tvar entry = undefined;\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\tif (this.match[0] === fromTitle && this.match[0][0] !== \\\"~\\\") {\\n\\t\\tentry = new SyslinkEntry();\\n\\t\\tentry.link = fromTitle;\\n\\t\\tentry.output = this.makeSyslink(toTitle, options);\\n\\t\\tif (entry.output === undefined) {\\n\\t\\t\\tentry.impossible = true;\\n\\t\\t}\\n\\t}\\n\\treturn entry;\\n};\\n\\nexports.makeSyslink = function(title, options) {\\n\\tvar match = title.match(this.matchRegExp);\\n\\tif (match && match[0] === title && title[0] !== \\\"~\\\") {\\n\\t\\treturn title;\\n\\t} else {\\n\\t\\treturn prettylink.makeLink(title, undefined, options);\\n\\t}\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/syslink.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/transclude.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nHandles replacement of transclusions in wiki text like,\\n\\n{{RenamedTiddler}}\\n{{RenamedTiddler||TemplateTitle}}\\n\\nThis renames both the tiddler and the template field.\\n\\n\\\\*/\\n\\nvar refHandler = require(\\\"$:/plugins/flibbles/relink/js/fieldtypes/reference\\\");\\nvar utils = require(\\\"./utils.js\\\");\\n\\nexports.name = ['transcludeinline', 'transcludeblock'];\\n\\nvar TranscludeEntry = function() {};\\nTranscludeEntry.prototype.name = \\\"transclude\\\";\\nTranscludeEntry.prototype.report = function() {\\n\\tvar ref = this.reference || {};\\n\\tvar output = [];\\n\\tif (this.referenceChanged) {\\n\\t\\tvar suffix = \\\"\\\";\\n\\t\\tif (ref.field) {\\n\\t\\t\\tsuffix = \\\"!!\\\" + ref.field;\\n\\t\\t}\\n\\t\\tif (ref.index) {\\n\\t\\t\\tsuffix = \\\"##\\\" + ref.index;\\n\\t\\t}\\n\\t\\tif (this.template) {\\n\\t\\t\\tsuffix = suffix + \\\"||\\\" + this.template;\\n\\t\\t}\\n\\t\\toutput.push(\\\"{{\\\" + suffix + \\\"}}\\\");\\n\\t}\\n\\tif (this.templateChanged) {\\n\\t\\t// Must be template\\n\\t\\tvar refString = refHandler.toString(ref);\\n\\t\\toutput.push(\\\"{{\\\" + refString + \\\"||}}\\\");\\n\\t}\\n\\treturn output;\\n};\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tvar m = this.match,\\n\\t\\treference = $tw.utils.parseTextReference(m[1]),\\n\\t\\ttemplate = m[2],\\n\\t\\tentry = new TranscludeEntry(),\\n\\t\\tmodified = false;\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\tif ($tw.utils.trim(reference.title) === fromTitle) {\\n\\t\\t// preserve user's whitespace\\n\\t\\treference.title = reference.title.replace(fromTitle, toTitle);\\n\\t\\tmodified = true;\\n\\t\\tentry.referenceChanged = true;\\n\\t}\\n\\tif ($tw.utils.trim(template) === fromTitle) {\\n\\t\\ttemplate = template.replace(fromTitle, toTitle);\\n\\t\\tmodified = true;\\n\\t\\tentry.templateChanged = true;\\n\\t}\\n\\tif (modified) {\\n\\t\\tentry.reference = reference;\\n\\t\\tentry.template = template;\\n\\t\\tvar output = this.makeTransclude(reference, template, options);\\n\\t\\tif (output) {\\n\\t\\t\\t// Adding any newline that might have existed is\\n\\t\\t\\t// what allows this relink method to work for both\\n\\t\\t\\t// the block and inline filter wikitext rule.\\n\\t\\t\\toutput = output + utils.getEndingNewline(m[0]);\\n\\t\\t\\tentry.output = output;\\n\\t\\t} else {\\n\\t\\t\\tentry.impossible = true;\\n\\t\\t}\\n\\t\\treturn entry;\\n\\t}\\n\\treturn undefined;\\n};\\n\\n/** This converts a reference and a template into a string representation\\n *  of a transclude.\\n */\\nexports.makeTransclude = function(reference, template, options) {\\n\\tvar rtn;\\n\\tif (!canBePrettyTemplate(template)) {\\n\\t\\tif (!options.noWidgets) {\\n\\t\\t\\tvar resultTemplate = wrap(template, options);\\n\\t\\t\\tif (resultTemplate !== undefined) {\\n\\t\\t\\t\\tif (reference.title) {\\n\\t\\t\\t\\t\\tvar resultTitle = wrap(reference.title, options);\\n\\t\\t\\t\\t\\tvar attrs = transcludeAttributes(reference.field, reference.index, options);\\n\\t\\t\\t\\t\\tif (resultTitle !== undefined && attrs !== undefined) {\\n\\t\\t\\t\\t\\t\\trtn = \\\"<$tiddler tiddler=\\\"+resultTitle+\\\"><$transclude tiddler=\\\"+resultTemplate+attrs+\\\"/></$tiddler>\\\";\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\trtn = \\\"<$transclude tiddler=\\\"+resultTemplate+\\\"/>\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else if (!canBePrettyTitle(reference.title)) {\\n\\t\\tif (!options.noWidgets) {\\n\\t\\t\\t// This block and the next account for the 1%...\\n\\t\\t\\tvar resultTitle = wrap(reference.title, options);\\n\\t\\t\\tif (resultTitle !== undefined) {\\n\\t\\t\\t\\tvar reducedRef = {field: reference.field, index: reference.index};\\n\\t\\t\\t\\trtn = \\\"<$tiddler tiddler=\\\"+resultTitle+\\\">\\\"+prettyTransclude(reducedRef, template)+\\\"</$tiddler>\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else {\\n\\t\\t// This block takes care of 99% of all cases\\n\\t\\trtn = prettyTransclude(reference, template);\\n\\t}\\n\\treturn rtn;\\n};\\n\\nfunction wrap(tiddler, options) {\\n\\ttiddler = $tw.utils.trim(tiddler);\\n\\tvar result = utils.wrapAttributeValue(tiddler);\\n\\tif (result === undefined) {\\n\\t\\tif (options.placeholder) {\\n\\t\\t\\tresult = \\\"<<\\\" + options.placeholder.getPlaceholderFor(tiddler, undefined, options) + \\\">>\\\";\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n};\\n\\nfunction canBePrettyTitle(value) {\\n\\treturn refHandler.canBePretty(value) && canBePrettyTemplate(value);\\n};\\n\\nfunction canBePrettyTemplate(value) {\\n\\treturn !value || (value.indexOf('}') < 0 && value.indexOf('{') < 0 && value.indexOf('|') < 0);\\n};\\n\\n/**Returns attributes for a transclude widget.\\n * only field or index should be used, not both, but both will return\\n * the intuitive (albeit useless) result.\\n */\\nfunction transcludeAttributes(field, index, options) {\\n\\tvar rtn = [\\n\\t\\twrapAttribute(\\\"field\\\", field, options),\\n\\t\\twrapAttribute(\\\"index\\\", index, options)\\n\\t];\\n\\tif (rtn[0] === undefined || rtn[1] === undefined) {\\n\\t\\t// This can only happen if the transclude is using an\\n\\t\\t// illegal key.\\n\\t\\treturn undefined;\\n\\t}\\n\\treturn rtn.join('');\\n};\\n\\nfunction wrapAttribute(name, value, options) {\\n\\tif (value) {\\n\\t\\tvar wrappedValue = utils.wrapAttributeValue(value);\\n\\t\\tif (wrappedValue === undefined) {\\n\\t\\t\\tif (!options.placeholder) {\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\t\\t\\twrappedValue = \\\"<<\\\"+options.placeholder.getPlaceholderFor(value, name, options)+\\\">>\\\";\\n\\t\\t}\\n\\t\\treturn \\\" \\\"+name+\\\"=\\\"+wrappedValue;\\n\\t}\\n\\treturn '';\\n};\\n\\nfunction prettyTransclude(textReference, template) {\\n\\tif (typeof textReference !== \\\"string\\\") {\\n\\t\\ttextReference = refHandler.toString(textReference);\\n\\t}\\n\\tif (!textReference) {\\n\\t\\ttextReference = '';\\n\\t}\\n\\tif (template !== undefined) {\\n\\t\\treturn \\\"{{\\\"+textReference+\\\"||\\\"+template+\\\"}}\\\";\\n\\t} else {\\n\\t\\treturn \\\"{{\\\"+textReference+\\\"}}\\\";\\n\\t}\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/transclude.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/utils.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: library\\n\\nUtility methods for the wikitext relink rules.\\n\\n\\\\*/\\n\\n/**Finds an appropriate quote mark for a given value.\\n *\\n *Tiddlywiki doesn't have escape characters for attribute values. Instead,\\n * we just have to find the type of quotes that'll work for the given title.\\n * There exist titles that simply can't be quoted.\\n * If it can stick with the preference, it will.\\n *\\n * return: Returns the wrapped value, or undefined if it's impossible to wrap\\n */\\nexports.wrapAttributeValue = function(value, preference) {\\n\\tvar whitelist = [\\\"\\\", \\\"'\\\", '\\\"', '\\\"\\\"\\\"'];\\n\\tvar choices = {\\n\\t\\t\\\"\\\": function(v) {return !/([\\\\/\\\\s<>\\\"'=])/.test(v); },\\n\\t\\t\\\"'\\\": function(v) {return v.indexOf(\\\"'\\\") < 0; },\\n\\t\\t'\\\"': function(v) {return v.indexOf('\\\"') < 0; },\\n\\t\\t'\\\"\\\"\\\"': function(v) {return v.indexOf('\\\"\\\"\\\"') < 0 && v[v.length-1] != '\\\"';}\\n\\t};\\n\\tif (choices[preference] && choices[preference](value)) {\\n\\t\\treturn wrap(value, preference);\\n\\t}\\n\\tfor (var i = 0; i < whitelist.length; i++) {\\n\\t\\tvar quote = whitelist[i];\\n\\t\\tif (choices[quote](value)) {\\n\\t\\t\\treturn wrap(value, quote);\\n\\t\\t}\\n\\t}\\n\\t// No quotes will work on this\\n\\treturn undefined;\\n};\\n\\n/**Like wrapAttribute value, except for macro parameters, not attributes.\\n *\\n * These are more permissive. Allows brackets,\\n * and slashes and '<' in unquoted values.\\n */\\nexports.wrapParameterValue = function(value, preference) {\\n\\tvar whitelist = [\\\"\\\", \\\"'\\\", '\\\"', '[[', '\\\"\\\"\\\"'];\\n\\tvar choices = {\\n\\t\\t\\\"\\\": function(v) {return !/([\\\\s>\\\"'=])/.test(v); },\\n\\t\\t\\\"'\\\": function(v) {return v.indexOf(\\\"'\\\") < 0; },\\n\\t\\t'\\\"': function(v) {return v.indexOf('\\\"') < 0; },\\n\\t\\t\\\"[[\\\": exports.canBePrettyOperand,\\n\\t\\t'\\\"\\\"\\\"': function(v) {return v.indexOf('\\\"\\\"\\\"') < 0 && v[v.length-1] != '\\\"';}\\n\\t};\\n\\tif (choices[preference] && choices[preference](value)) {\\n\\t\\treturn wrap(value, preference);\\n\\t}\\n\\tfor (var i = 0; i < whitelist.length; i++) {\\n\\t\\tvar quote = whitelist[i];\\n\\t\\tif (choices[quote](value)) {\\n\\t\\t\\treturn wrap(value, quote);\\n\\t\\t}\\n\\t}\\n\\t// No quotes will work on this\\n\\treturn undefined;\\n};\\n\\nfunction wrap(value, wrapper) {\\n\\tvar wrappers = {\\n\\t\\t\\\"\\\": function(v) {return v; },\\n\\t\\t\\\"'\\\": function(v) {return \\\"'\\\"+v+\\\"'\\\"; },\\n\\t\\t'\\\"': function(v) {return '\\\"'+v+'\\\"'; },\\n\\t\\t'\\\"\\\"\\\"': function(v) {return '\\\"\\\"\\\"'+v+'\\\"\\\"\\\"'; },\\n\\t\\t\\\"[[\\\": function(v) {return \\\"[[\\\"+v+\\\"]]\\\"; }\\n\\t};\\n\\tvar chosen = wrappers[wrapper];\\n\\tif (chosen) {\\n\\t\\treturn chosen(value);\\n\\t} else {\\n\\t\\treturn undefined;\\n\\t}\\n};\\n\\nexports.canBePrettyOperand = function(value) {\\n\\treturn value.indexOf(']') < 0;\\n};\\n\\n/**Given some text, and a param or  attribute within that text, this returns\\n * what type of quotation that attribute is using.\\n *\\n * param: An object in the form {end:, ...}\\n */\\nexports.determineQuote = function(text, param) {\\n\\tvar pos = param.end-1;\\n\\tif (text[pos] === \\\"'\\\") {\\n\\t\\treturn \\\"'\\\";\\n\\t}\\n\\tif (text[pos] === '\\\"') {\\n\\t\\tif (text.substr(pos-2, 3) === '\\\"\\\"\\\"') {\\n\\t\\t\\treturn '\\\"\\\"\\\"';\\n\\t\\t} else {\\n\\t\\t\\treturn '\\\"';\\n\\t\\t}\\n\\t}\\n\\tif (text.substr(pos-1,2) === ']]' && text.substr((pos-param.value.length)-3, 2) === '[[') {\\n\\t\\treturn \\\"[[\\\";\\n\\t}\\n\\treturn '';\\n};\\n\\n// Finds the newline at the end of a string and returns it. Empty string if\\n// none exists.\\nexports.getEndingNewline = function(string) {\\n\\tvar l = string.length;\\n\\tif (string[l-1] === '\\\\n') {\\n\\t\\treturn (string[l-2] === '\\\\r') ? \\\"\\\\r\\\\n\\\" : \\\"\\\\n\\\";\\n\\t}\\n\\treturn \\\"\\\";\\n};\\n\",\n            \"module-type\": \"library\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/utils.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/wikilink.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: relinkwikitextrule\\n\\nHandles CamelCase links\\n\\nWikiLink\\n\\nbut not:\\n\\n~WikiLink\\n\\n\\\\*/\\n\\nvar utils = require(\\\"./utils.js\\\");\\nvar prettylink = require('$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/prettylink.js');\\n\\nexports.name = \\\"wikilink\\\";\\n\\nfunction WikilinkEntry() {};\\nWikilinkEntry.prototype.name = \\\"wikilink\\\";\\nWikilinkEntry.prototype.report = function() {\\n\\treturn [$tw.config.textPrimitives.unWikiLink + this.link];\\n};\\n\\nexports.relink = function(text, fromTitle, toTitle, options) {\\n\\tvar entry = undefined;\\n\\tthis.parser.pos = this.matchRegExp.lastIndex;\\n\\tif (this.match[0] === fromTitle && this.match[0][0] !== $tw.config.textPrimitives.unWikiLink) {\\n\\t\\tentry = new WikilinkEntry();\\n\\t\\tentry.link = fromTitle;\\n\\t\\tentry.output = this.makeWikilink(toTitle, options);\\n\\t\\tif (entry.output === undefined) {\\n\\t\\t\\tentry.impossible = true;\\n\\t\\t}\\n\\t}\\n\\treturn entry;\\n};\\n\\nexports.makeWikilink = function(title, options) {\\n\\tif (title.match(this.matchRegExp) && title[0] !== $tw.config.textPrimitives.unWikiLink) {\\n\\t\\treturn title;\\n\\t} else {\\n\\t\\treturn prettylink.makeLink(title, undefined, options);\\n\\t}\\n};\\n\",\n            \"module-type\": \"relinkwikitextrule\",\n            \"title\": \"$:/plugins/flibbles/relink/js/relinkoperations/text/wikitext/wikilink.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/surveyors/raw.js\": {\n            \"text\": \"/*\\\\\\n\\nThis looks at text and sees if fromTitle is inside of it. That's all.\\n\\nSURVEYORS\\n\\nSurveyors are an optimization. They are way of quick-discarding text so it\\ndoesn't have to be interpreted by the wikitext parser, the filter parser,\\netc...\\n\\nThe reason I split this off into a module type is in case anyone wants to\\nrelink patterns which might NOT contain the fromTitle in raw text.\\n\\nThey return false for \\\"no\\\", and true for \\\"maybe\\\". If any surveyor returns\\n\\\"maybe\\\", the text in question is fully parsed.\\n\\nSee the documentation for more details.\\n\\n\\\\*/\\n\\nexports.survey = function(text, fromTitle, options) {\\n\\treturn text.indexOf(fromTitle) >= 0;\\n};\\n\",\n            \"module-type\": \"relinksurveyor\",\n            \"title\": \"$:/plugins/flibbles/relink/js/surveyors/raw.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/utils/entry.js\": {\n            \"text\": \"function EntryNode() {\\n\\tthis.children = [];\\n};\\n\\nmodule.exports = EntryNode;\\n\\n/**  PURE VIRTUAL\\n * EntryNode.prototype.report = function() -> [\\\"string\\\", ...]\\n */\\n\\nEntryNode.newType = function(name) {\\n\\tfunction NewEntry() {\\n\\t\\tEntryNode.apply(this, arguments);\\n\\t};\\n\\tNewEntry.prototype = Object.create(EntryNode.prototype);\\n\\tNewEntry.prototype.name = name;\\n\\treturn NewEntry;\\n};\\n\\nEntryNode.prototype.eachChild = function(method) {\\n\\tif (this.children) {\\n\\t\\tfor (var i = 0; i < this.children.length; i++) {\\n\\t\\t\\tmethod(this.children[i]);\\n\\t\\t}\\n\\t}\\n};\\n\\nEntryNode.prototype.add = function(entry) {\\n\\tthis.children.push(entry);\\n};\\n\\nEntryNode.prototype.report = function() {\\n\\tvar output = [];\\n\\t$tw.utils.each(this.children, function(child) {\\n\\t\\t// All wikitext children should be able to report\\n\\t\\t$tw.utils.each(child.report(), function(report) {\\n\\t\\t\\toutput.push(report);\\n\\t\\t});\\n\\t});\\n\\treturn output;\\n};\\n\\nfunction EntryCollection() {\\n\\tthis.children = Object.create(null);\\n\\tthis.types = Object.create(null);\\n};\\n\\nEntryNode.newCollection = function(name) {\\n\\tfunction NewCollection() {\\n\\t\\tEntryCollection.apply(this, arguments);\\n\\t};\\n\\tNewCollection.prototype = Object.create(EntryCollection.prototype);\\n\\tNewCollection.prototype.name = name;\\n\\treturn NewCollection;\\n};\\n\\nEntryCollection.prototype.eachChild = function(method) {\\n\\tfor (var child in this.children) {\\n\\t\\tmethod(this.children[child]);\\n\\t}\\n};\\n\\nEntryCollection.prototype.addChild = function(child, name, type) {\\n\\tthis.children[name] = child;\\n\\tthis.types[name] = type;\\n};\\n\\nEntryCollection.prototype.report = function() {\\n\\tvar output = [];\\n\\tfor (var name in this.children) {\\n\\t\\tvar child = this.children[name];\\n\\t\\tvar type = this.types[name];\\n\\t\\tif (child.report) {\\n\\t\\t\\tvar reports = child.report();\\n\\t\\t\\tfor (var i = 0; i < reports.length; i++) {\\n\\t\\t\\t\\toutput.push(this.forEachChildReport(reports[i], name, type));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\toutput.push(this.forEachChildReport('', name, type));\\n\\n\\t\\t}\\n\\t}\\n\\treturn output;\\n};\\n\\nEntryCollection.prototype.hasChildren = function() {\\n\\treturn Object.keys(this.children).length > 0;\\n};\\n\",\n            \"module-type\": \"library\",\n            \"title\": \"$:/plugins/flibbles/relink/js/utils/entry.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/utils/macroConfig.js\": {\n            \"text\": \"/*\\\\\\nmodule-type: library\\n\\nThis handles the fetching and distribution of relink settings.\\n\\n\\\\*/\\n\\nvar settings = require('$:/plugins/flibbles/relink/js/settings.js');\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nfunction MacroConfig(wiki, parent, title) {\\n\\tthis.macros = Object.create(null);\\n\\tthis.parent = parent;\\n\\tthis.title = title;\\n\\tthis.wiki = wiki;\\n\\tthis.widgetList = [];\\n\\tthis.reservedmacroNames = Object.create(null);\\n};\\n\\nmodule.exports = MacroConfig;\\n\\nMacroConfig.prototype.import = function(filter) {\\n\\tvar parentWidget;\\n\\tif (this.parent) {\\n\\t\\tparentWidget = this.getVariableWidget();\\n\\t}\\n\\tvar importWidget = createImportWidget(filter, this.wiki, parentWidget);\\n\\tthis._compileList(importWidget.tiddlerList);\\n\\tthis.widgetList.push(importWidget);\\n\\t// This only works if only one filter is imported\\n\\tthis.addWidget(importWidget);\\n};\\n\\nMacroConfig.prototype.refresh = function(changes) {\\n\\tthis.parent.refresh(changes);\\n\\tif (this.widget.refresh(changes)) {\\n\\t\\tthis.macros = Object.create(null);\\n\\t\\t// Recompile all our widgets in the same order\\n\\t\\tfor (var i = 0; i < this.widgetList.length; i++) {\\n\\t\\t\\tthis._compileList(this.widgetList[i].tiddlerList );\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n};\\n\\n// So fieldtypes can access settings through options.settings, instead of\\n// including this file, which they can't, because that'd be cyclical dependency\\nMacroConfig.prototype.getType = function(name) {\\n\\treturn settings.getType(name);\\n};\\n\\n// This class does no special handling of fields, operators, or attributes.\\n// we pass it along to the parent.\\nMacroConfig.prototype.getFields = function() {\\n\\treturn this.parent.getFields();\\n};\\n\\nMacroConfig.prototype.getOperators = function() {\\n\\treturn this.parent.getOperators();\\n};\\n\\nMacroConfig.prototype.getAttributes = function() {\\n\\treturn this.parent.getAttributes();\\n};\\n\\nMacroConfig.prototype.survey = function(text, fromTitle, options) {\\n\\treturn this.parent.survey(text, fromTitle, options);\\n};\\n\\nMacroConfig.prototype.getAttribute = function(elementName) {\\n\\treturn this.parent.getAttribute(elementName);\\n};\\n\\nMacroConfig.prototype.getMacros = function() {\\n\\tvar signatures = this.parent.getMacros();\\n\\tfor (var macroName in this.macros) {\\n\\t\\tvar macro = this.macros[macroName];\\n\\t\\tfor (var param in macro) {\\n\\t\\t\\tsignatures[macroName + \\\"/\\\" + param] = macro[param];\\n\\t\\t}\\n\\t}\\n\\treturn signatures;\\n};\\n\\n// But macro we handle differently.\\nMacroConfig.prototype.getMacro = function(macroName) {\\n\\tvar theseSettings = this.macros[macroName];\\n\\tvar parentSettings;\\n\\tif (this.parent) {\\n\\t\\tparentSettings = this.parent.getMacro(macroName);\\n\\t}\\n\\tif (theseSettings && parentSettings) {\\n\\t\\t// gotta merge them without changing either. This is expensive,\\n\\t\\t// but it'll happen rarely.\\n\\t\\tvar rtnSettings = $tw.utils.extend(Object.create(null), theseSettings, parentSettings);\\n\\t\\treturn rtnSettings;\\n\\t}\\n\\treturn theseSettings || parentSettings;\\n};\\n\\nMacroConfig.prototype.addSetting = function(macroName, parameter, type, sourceTitle) {\\n\\tvar macro = this.macros[macroName];\\n\\ttype = type || settings.getDefaultType(this.wiki);\\n\\tif (macro === undefined) {\\n\\t\\tmacro = this.macros[macroName] = Object.create(null);\\n\\t}\\n\\tvar handler = settings.getType(type);\\n\\tif (handler) {\\n\\t\\thandler.source = sourceTitle;\\n\\t\\t// We attach the fields of the defining tiddler for the benefit\\n\\t\\t// of any 3rd party field types that want access to them.\\n\\t\\tvar tiddler = this.wiki.getTiddler(sourceTitle);\\n\\t\\thandler.fields = tiddler.fields;\\n\\t\\tmacro[parameter] = handler;\\n\\t}\\n};\\n\\nMacroConfig.prototype.createChildLibrary = function(title) {\\n\\treturn new MacroConfig(this.wiki, this, title);\\n};\\n\\nMacroConfig.prototype.addWidget = function(widget) {\\n\\tthis.widget = widget;\\n\\twhile (this.widget.children.length > 0) {\\n\\t\\tthis.widget = this.widget.children[0];\\n\\t}\\n};\\n\\nMacroConfig.prototype.getVariableWidget = function() {\\n\\tif (!this.widget) {\\n\\t\\tvar varWidget = this.parent && this.parent.widget;\\n\\t\\tvar parentWidget = new Widget({}, {parentWidget: varWidget});\\n\\t\\tparentWidget.setVariable(\\\"currentTiddler\\\", this.title);\\n\\t\\tvar widget = new Widget({}, {parentWidget: parentWidget});\\n\\t\\tthis.addWidget(widget);\\n\\t}\\n\\treturn this.widget;\\n};\\n\\n/**This takes macros, specifically relink placeholders, and remembers them\\n * It creates a dummy object for them, since we'll never need the definition\\n */\\nMacroConfig.prototype.reserveMacroName = function(variableName) {\\n\\tthis.reservedmacroNames[variableName] = {\\n\\t\\tvalue: \\\"\\\",\\n\\t\\tparams: []};\\n};\\n\\nMacroConfig.prototype.addMacroDefinition = function(setParseTreeNode) {\\n\\tvar bottomWidget = this.getVariableWidget();\\n\\tvar setWidget = bottomWidget.makeChildWidget(setParseTreeNode);\\n\\tsetWidget.computeAttributes();\\n\\tsetWidget.execute();\\n\\tthis.addWidget(setWidget);\\n};\\n\\nMacroConfig.prototype.getMacroDefinition = function(variableName) {\\n\\treturn this.getVariableWidget().variables[variableName] || $tw.macros[variableName] || this.reservedmacroNames[variableName];\\n};\\n\\nfunction createImportWidget(filter, wiki, parent) {\\n\\tvar widget = wiki.makeWidget( { tree: [{\\n\\t\\ttype: \\\"importvariables\\\",\\n\\t\\tattributes: {\\n\\t\\t\\t\\\"filter\\\": {\\n\\t\\t\\t\\ttype: \\\"string\\\",\\n\\t\\t\\t\\tvalue: filter\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}] }, { parentWidget: parent} );\\n\\twidget.execute();\\n\\twidget.renderChildren();\\n\\tvar importWidget = widget.children[0];\\n\\treturn importWidget;\\n};\\n\\nMacroConfig.prototype._compileList = function(titleList) {\\n\\tfor (var i = 0; i < titleList.length; i++) {\\n\\t\\tvar parser = this.wiki.parseTiddler(titleList[i]);\\n\\t\\tif (parser) {\\n\\t\\t\\tvar parseTreeNode = parser.tree[0];\\n\\t\\t\\twhile (parseTreeNode && parseTreeNode.type === \\\"set\\\") {\\n\\t\\t\\t\\tif (parseTreeNode.relink) {\\n\\t\\t\\t\\t\\tfor (var macroName in parseTreeNode.relink) {\\n\\t\\t\\t\\t\\t\\tvar parameters = parseTreeNode.relink[macroName];\\n\\t\\t\\t\\t\\t\\tfor (paramName in parameters) {\\n\\t\\t\\t\\t\\t\\t\\tthis.addSetting(macroName, paramName, parameters[paramName], titleList[i]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tparseTreeNode = parseTreeNode.children && parseTreeNode.children[0];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\",\n            \"module-type\": \"library\",\n            \"title\": \"$:/plugins/flibbles/relink/js/utils/macroConfig.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/utils/placeholder.js\": {\n            \"text\": \"/*\\\\\\n\\nA method which doles out placeholders when requested, and constructs\\nthe necessary supporting pragma when requested.\\n\\n\\\\*/\\n\\nfunction Placeholder() {\\n\\tthis.placeholders = Object.create(null);\\n\\tthis.reverseMap = Object.create(null);\\n};\\n\\nmodule.exports = Placeholder;\\n\\nPlaceholder.prototype.getPlaceholderFor = function(value, category, options) {\\n\\tvar placeholder = this.reverseMap[value];\\n\\tvar config = options.settings || options.wiki.getRelinkConfig();\\n\\tif (placeholder) {\\n\\t\\treturn placeholder;\\n\\t}\\n\\tvar number = 0;\\n\\tvar prefix = \\\"relink-\\\"\\n\\tif (category && category !== \\\"title\\\") {\\n\\t\\t// I don't like \\\"relink-title-1\\\". \\\"relink-1\\\" should be for\\n\\t\\t// titles. lists, and filters can have descriptors though.\\n\\t\\tprefix += category + \\\"-\\\";\\n\\t}\\n\\tdo {\\n\\t\\tnumber += 1;\\n\\t\\tplaceholder = prefix + number;\\n\\t} while (config.getMacroDefinition(placeholder));\\n\\tconfig.reserveMacroName(placeholder);\\n\\tthis.placeholders[placeholder] = value;\\n\\tthis.reverseMap[value] = placeholder;\\n\\treturn placeholder;\\n};\\n\\nPlaceholder.prototype.getPreamble = function() {\\n\\tvar results = [];\\n\\tfor (var name in this.placeholders) {\\n\\t\\tvar val = this.placeholders[name];\\n\\t\\tresults.push(\\\"\\\\\\\\define \\\"+name+\\\"() \\\"+val+\\\"\\\\n\\\");\\n\\t}\\n\\treturn results.join('');\\n};\\n\\n\",\n            \"module-type\": \"library\",\n            \"title\": \"$:/plugins/flibbles/relink/js/utils/placeholder.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/plugins/flibbles/relink/js/utils/rebuilder.js\": {\n            \"text\": \"/*\\\\\\n\\nThis helper class aids in reconstructing an existing string with new parts.\\n\\n\\\\*/\\n\\nfunction Rebuilder(text, start) {\\n\\tthis.text = text;\\n\\tthis.index = start || 0;\\n\\tthis.pieces = [];\\n};\\n\\nmodule.exports = Rebuilder;\\n\\n/**Pieces must be added consecutively.\\n * Start and end are the indices in the old string specifying where to graft\\n * in the new piece.\\n */\\nRebuilder.prototype.add = function(value, start, end) {\\n\\tthis.pieces.push(this.text.substring(this.index, start), value);\\n\\tthis.index = end;\\n};\\n\\nRebuilder.prototype.changed = function() {\\n\\treturn this.pieces.length > 0;\\n};\\n\\nRebuilder.prototype.results = function(end) {\\n\\tif (this.changed()) {\\n\\t\\tthis.pieces.push(this.text.substring(this.index, end));\\n\\t\\treturn this.pieces.join('');\\n\\t}\\n\\treturn undefined;\\n};\\n\",\n            \"module-type\": \"library\",\n            \"title\": \"$:/plugins/flibbles/relink/js/utils/rebuilder.js\",\n            \"type\": \"application/javascript\"\n        },\n        \"$:/config/flibbles/relink/attributes/$button/set\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$button/set\",\n            \"text\": \"reference\"\n        },\n        \"$:/config/flibbles/relink/attributes/$button/setTo\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$button/setTo\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$button/to\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$button/to\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$checkbox/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$checkbox/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$checkbox/tag\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$checkbox/tag\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$count/filter\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$count/filter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/attributes/$draggable/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$draggable/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$draggable/filter\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$draggable/filter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/attributes/$edit-bitmap/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$edit-bitmap/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$edit-text/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$edit-text/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$edit/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$edit/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$encrypt/filter\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$encrypt/filter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/attributes/$fieldmangler/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$fieldmangler/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$fields/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$fields/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$image/source\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$image/source\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$importvariables/filter\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$importvariables/filter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/attributes/$linkcatcher/to\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$linkcatcher/to\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$linkcatcher/set\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$linkcatcher/set\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$link/to\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$link/to\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$list/filter\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$list/filter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/attributes/$list/template\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$list/template\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$list/editTemplate\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$list/editTemplate\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$list/history\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$list/history\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$navigator/story\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$navigator/story\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$navigator/history\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$navigator/history\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$radio/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$radio/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$range/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$range/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$reveal/stateTitle\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$reveal/stateTitle\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$select/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$select/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$setvariable/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$setvariable/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$setvariable/subtiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$setvariable/subtiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$setvariable/filter\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$setvariable/filter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/attributes/$set/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$set/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$set/subtiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$set/subtiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$set/filter\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$set/filter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/attributes/$tiddler/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$tiddler/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$transclude/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$transclude/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$transclude/subtiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$transclude/subtiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$view/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$view/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/attributes/$view/subtiddler\": {\n            \"title\": \"$:/config/flibbles/relink/attributes/$view/subtiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/plugins/flibbles/relink/configuration\": {\n            \"title\": \"$:/plugins/flibbles/relink/configuration\",\n            \"text\": \"<div class=\\\"tc-control-panel\\\">\\n<<tabs \\\"[all[shadows+tiddlers]tag[$:/tags/flibbles/relink/Configuration]!has[draft.of]]\\\" \\\"$:/plugins/flibbles/relink/ui/configuration/Fields\\\">>\\n</div>\\n\"\n        },\n        \"$:/config/flibbles/relink/fields/caption\": {\n            \"title\": \"$:/config/flibbles/relink/fields/caption\",\n            \"text\": \"wikitext\"\n        },\n        \"$:/config/flibbles/relink/fields/filter\": {\n            \"title\": \"$:/config/flibbles/relink/fields/filter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/fields/list\": {\n            \"title\": \"$:/config/flibbles/relink/fields/list\",\n            \"text\": \"list\"\n        },\n        \"$:/config/flibbles/relink/fields/list-after\": {\n            \"title\": \"$:/config/flibbles/relink/fields/list-after\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/fields/list-before\": {\n            \"title\": \"$:/config/flibbles/relink/fields/list-before\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/fields/tags\": {\n            \"title\": \"$:/config/flibbles/relink/fields/tags\",\n            \"text\": \"list\"\n        },\n        \"$:/plugins/flibbles/relink/language/PluginLibrary\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/PluginLibrary\",\n            \"text\": \"//Relink// Library\"\n        },\n        \"$:/plugins/flibbles/relink/language/PluginLibrary/Hint\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/PluginLibrary/Hint\",\n            \"text\": \"The //Relink// library contains //Relink// as well as its supplemental plugins. It is maintained by Flibbles. See the <a href={{$:/plugins/flibbles/relink!!source}}>github page</a> for more information.\"\n        },\n        \"$:/plugins/flibbles/relink/language/Buttons/Delete/Hint\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Buttons/Delete/Hint\",\n            \"text\": \"delete\"\n        },\n        \"$:/plugins/flibbles/relink/language/Buttons/LinkToInline/Hint\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Buttons/LinkToInline/Hint\",\n            \"text\": \"go to defining tiddler\"\n        },\n        \"$:/plugins/flibbles/relink/language/Buttons/NewAttribute/Hint\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Buttons/NewAttribute/Hint\",\n            \"text\": \"Specify a new widget/element attribute to be updated whenever a tiddler is renamed\"\n        },\n        \"$:/plugins/flibbles/relink/language/Buttons/NewAttribute/Caption\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Buttons/NewAttribute/Caption\",\n            \"text\": \"add\"\n        },\n        \"$:/plugins/flibbles/relink/language/Buttons/NewField/Hint\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Buttons/NewField/Hint\",\n            \"text\": \"Specify a new field to be updated whenever a tiddler is renamed\"\n        },\n        \"$:/plugins/flibbles/relink/language/Buttons/NewField/Caption\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Buttons/NewField/Caption\",\n            \"text\": \"add\"\n        },\n        \"$:/plugins/flibbles/relink/language/Buttons/NewOperator/Hint\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Buttons/NewOperator/Hint\",\n            \"text\": \"Specify a new filter operator to be considered whenever a tiddler is renamed\"\n        },\n        \"$:/plugins/flibbles/relink/language/Buttons/NewOperator/Caption\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Buttons/NewOperator/Caption\",\n            \"text\": \"add\"\n        },\n        \"$:/plugins/flibbles/relink/language/Buttons/NewParameter/Hint\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Buttons/NewParameter/Hint\",\n            \"text\": \"Specify a new macro parameter to be updated whenever a tiddler is renamed\"\n        },\n        \"$:/plugins/flibbles/relink/language/Buttons/NewParameter/Caption\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Buttons/NewParameter/Caption\",\n            \"text\": \"add\"\n        },\n        \"$:/plugins/flibbles/relink/language/Error/InvalidAttributeName\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Error/InvalidAttributeName\",\n            \"text\": \"Illegal characters in attribute name \\\"<$text text=<<attributeName>>/>\\\". Attributes cannot contain slashes ('/'), closing angle or square brackets ('>' or ']'), quotes or apostrophes ('\\\"' or \\\"'\\\"), equals ('='), or whitespace\"\n        },\n        \"$:/plugins/flibbles/relink/language/Error/InvalidElementName\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Error/InvalidElementName\",\n            \"text\": \"Illegal characters in element/widget name \\\"<$text text=<<elementName>>/>\\\". Element tags can only contain letters and the characters hyphen (`-`) and dollar sign (`$`)\"\n        },\n        \"$:/plugins/flibbles/relink/language/Error/InvalidMacroName\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Error/InvalidMacroName\",\n            \"text\": \"Illegal characters in macro name \\\"<$text text=<<macroName>>/>\\\". Macros cannot contain whitespace\"\n        },\n        \"$:/plugins/flibbles/relink/language/Error/InvalidParameterName\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Error/InvalidParameterName\",\n            \"text\": \"Illegal characters in parameter name \\\"<$text text=<<parameterName>>/>\\\". Parameters can only contain letters, digits, and the characters underscore (`_`) and hyphen (`-`)\"\n        },\n        \"$:/plugins/flibbles/relink/language/Error/RelinkFilterOperator\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Error/RelinkFilterOperator\",\n            \"text\": \"Filter Error: Unknown suffix for the 'relink' filter operator\"\n        },\n        \"$:/plugins/flibbles/relink/language/Error/ReportFailedRelinks\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Error/ReportFailedRelinks\",\n            \"text\": \"Relink could not update '<<from>>' to '<<to>>' inside the following tiddlers:\"\n        },\n        \"$:/plugins/flibbles/relink/language/Error/UnrecognizedType\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Error/UnrecognizedType\",\n            \"text\": \"Relink parse error: Unrecognized field type '<<type>>'\"\n        },\n        \"$:/plugins/flibbles/relink/language/Help/Attributes\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Help/Attributes\",\n            \"text\": \"See the <a href={{{[{$:/plugins/flibbles/relink!!demo}addsuffix[#Attributes]]}}}>Attributes documentation page</a> for details.\"\n        },\n        \"$:/plugins/flibbles/relink/language/Help/Fields\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Help/Fields\",\n            \"text\": \"See the <a href={{{[{$:/plugins/flibbles/relink!!demo}addsuffix[#Fields]]}}}>Fields documentation page</a> for details.\"\n        },\n        \"$:/plugins/flibbles/relink/language/Help/Macros\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Help/Macros\",\n            \"text\": \"See the <a href={{{[{$:/plugins/flibbles/relink!!demo}addsuffix[#Macros]]}}}>Macros documentation page</a> for details.\"\n        },\n        \"$:/plugins/flibbles/relink/language/Help/Operators\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/Help/Operators\",\n            \"text\": \"See the <a href={{{[{$:/plugins/flibbles/relink!!demo}addsuffix[#Operators]]}}}>Operators documentation page</a> for details.\"\n        },\n        \"$:/plugins/flibbles/relink/language/TiddlerInfo/References/Empty\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/TiddlerInfo/References/Empty\",\n            \"text\": \"No tiddlers contain any fields, links, macros, transclusions, or widgets referencing this one\"\n        },\n        \"$:/plugins/flibbles/relink/language/TiddlerInfo/References/Description\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/TiddlerInfo/References/Description\",\n            \"text\": \"The following tiddlers contain fields, links, macros, transclusions, or widgets referencing this one:\"\n        },\n        \"$:/plugins/flibbles/relink/language/TiddlerInfo/References/Caption\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/TiddlerInfo/References/Caption\",\n            \"text\": \"//Relink// References\"\n        },\n        \"$:/plugins/flibbles/relink/language/ui/Attributes/Caption\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/ui/Attributes/Caption\",\n            \"text\": \"Attributes\"\n        },\n        \"$:/plugins/flibbles/relink/language/ui/Fields/Caption\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/ui/Fields/Caption\",\n            \"text\": \"Fields\"\n        },\n        \"$:/plugins/flibbles/relink/language/ui/Macros/Caption\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/ui/Macros/Caption\",\n            \"text\": \"Macros\"\n        },\n        \"$:/plugins/flibbles/relink/language/ui/Operators/Caption\": {\n            \"title\": \"$:/plugins/flibbles/relink/language/ui/Operators/Caption\",\n            \"text\": \"Operators\"\n        },\n        \"$:/config/flibbles/relink/macros/csvtiddlers/filter\": {\n            \"title\": \"$:/config/flibbles/relink/macros/csvtiddlers/filter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/macros/datauri/title\": {\n            \"title\": \"$:/config/flibbles/relink/macros/datauri/title\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/jsontiddler/title\": {\n            \"title\": \"$:/config/flibbles/relink/macros/jsontiddler/title\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/jsontiddlers/filter\": {\n            \"title\": \"$:/config/flibbles/relink/macros/jsontiddlers/filter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/macros/list-links/filter\": {\n            \"title\": \"$:/config/flibbles/relink/macros/list-links/filter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/macros/list-links-draggable/tiddler\": {\n            \"title\": \"$:/config/flibbles/relink/macros/list-links-draggable/tiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/list-links-draggable/itemTemplate\": {\n            \"title\": \"$:/config/flibbles/relink/macros/list-links-draggable/itemTemplate\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/list-tagged-draggable/tag\": {\n            \"title\": \"$:/config/flibbles/relink/macros/list-tagged-draggable/tag\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/list-tagged-draggable/itemTemplate\": {\n            \"title\": \"$:/config/flibbles/relink/macros/list-tagged-draggable/itemTemplate\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/tabs/buttonTemplate\": {\n            \"title\": \"$:/config/flibbles/relink/macros/tabs/buttonTemplate\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/tabs/default\": {\n            \"title\": \"$:/config/flibbles/relink/macros/tabs/default\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/tabs/tabsList\": {\n            \"title\": \"$:/config/flibbles/relink/macros/tabs/tabsList\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/macros/tabs/template\": {\n            \"title\": \"$:/config/flibbles/relink/macros/tabs/template\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/tag/tag\": {\n            \"title\": \"$:/config/flibbles/relink/macros/tag/tag\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/tag-pill/tag\": {\n            \"title\": \"$:/config/flibbles/relink/macros/tag-pill/tag\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/timeline/subfilter\": {\n            \"title\": \"$:/config/flibbles/relink/macros/timeline/subfilter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/macros/toc/tag\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc/tag\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/toc/itemClassFilter\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc/itemClassFilter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-expandable/tag\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-expandable/tag\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-expandable/itemClassFilter\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-expandable/itemClassFilter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-expandable/exclude\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-expandable/exclude\",\n            \"text\": \"list\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-selective-expandable/tag\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-selective-expandable/tag\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-selective-expandable/itemClassFilter\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-selective-expandable/itemClassFilter\",\n            \"text\": \"filter\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-selective-expandable/exclude\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-selective-expandable/exclude\",\n            \"text\": \"list\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-tabbed-external-nav/tag\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-tabbed-external-nav/tag\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-tabbed-external-nav/selectedTiddler\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-tabbed-external-nav/selectedTiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-tabbed-external-nav/unselectedText\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-tabbed-external-nav/unselectedText\",\n            \"text\": \"wikitext\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-tabbed-external-nav/missingText\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-tabbed-external-nav/missingText\",\n            \"text\": \"wikitext\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-tabbed-external-nav/template\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-tabbed-external-nav/template\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-tabbed-internal-nav/tag\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-tabbed-internal-nav/tag\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-tabbed-internal-nav/selectedTiddler\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-tabbed-internal-nav/selectedTiddler\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-tabbed-internal-nav/unselectedText\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-tabbed-internal-nav/unselectedText\",\n            \"text\": \"wikitext\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-tabbed-internal-nav/missingText\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-tabbed-internal-nav/missingText\",\n            \"text\": \"wikitext\"\n        },\n        \"$:/config/flibbles/relink/macros/toc-tabbed-internal-nav/template\": {\n            \"title\": \"$:/config/flibbles/relink/macros/toc-tabbed-internal-nav/template\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/operators/list\": {\n            \"title\": \"$:/config/flibbles/relink/operators/list\",\n            \"text\": \"reference\"\n        },\n        \"$:/config/flibbles/relink/operators/tag\": {\n            \"title\": \"$:/config/flibbles/relink/operators/tag\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/operators/title\": {\n            \"title\": \"$:/config/flibbles/relink/operators/title\",\n            \"text\": \"title\"\n        },\n        \"$:/config/flibbles/relink/operators/field:title\": {\n            \"title\": \"$:/config/flibbles/relink/operators/field:title\",\n            \"text\": \"title\"\n        },\n        \"$:/language/EditTemplate/Title/Impossibles/Prompt\": {\n            \"title\": \"$:/language/EditTemplate/Title/Impossibles/Prompt\",\n            \"text\": \"''Warning:'' Not all references in the following tiddlers can be updated by //Relink// due to the complexity of the new title:\"\n        },\n        \"$:/language/EditTemplate/Title/References/Prompt\": {\n            \"title\": \"$:/language/EditTemplate/Title/References/Prompt\",\n            \"text\": \"The following tiddlers will be updated if relinking:\"\n        },\n        \"$:/language/EditTemplate/Title/Relink/Prompt\": {\n            \"title\": \"$:/language/EditTemplate/Title/Relink/Prompt\",\n            \"text\": \"Use //Relink// to update ''<$text text=<<fromTitle>>/>'' to ''<$text text=<<toTitle>>/>'' across all other tiddlers\"\n        },\n        \"$:/core/ui/EditTemplate/title\": {\n            \"title\": \"$:/core/ui/EditTemplate/title\",\n            \"tags\": \"$:/tags/EditTemplate\",\n            \"text\": \"<$edit-text field=\\\"draft.title\\\" class=\\\"tc-titlebar tc-edit-texteditor\\\" focus=\\\"true\\\" tabindex={{$:/config/EditTabIndex}}/>\\n\\n<$reveal state=\\\"!!draft.title\\\" type=\\\"nomatch\\\" text={{!!draft.of}} tag=\\\"div\\\">\\n\\n<$list filter=\\\"[{!!draft.title}!is[missing]]\\\" variable=\\\"listItem\\\">\\n\\n<div class=\\\"tc-message-box\\\">\\n\\n{{$:/core/images/warning}} {{$:/language/EditTemplate/Title/Exists/Prompt}}\\n\\n</div>\\n\\n</$list>\\n\\n<$list filter=\\\"[{!!draft.of}!is[missing]]\\\" variable=\\\"listItem\\\">\\n\\n<$vars fromTitle={{!!draft.of}} toTitle={{!!draft.title}}>\\n\\n<$checkbox tiddler=\\\"$:/config/RelinkOnRename\\\" field=\\\"text\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"no\\\"> {{$:/language/EditTemplate/Title/Relink/Prompt}}</$checkbox>\\n\\n<$list filter=\\\"[all[relinkable]relink:references<fromTitle>limit[1]]\\\" variable=\\\"listItem\\\">\\n\\n<$vars stateTiddler=<<qualify \\\"$:/state/edit/references\\\">> >\\n\\n<$tiddler tiddler=<<fromTitle>> >\\n\\n<$set\\n\\tname=\\\"prompt\\\"\\n\\tfilter=\\\"[all[relinkable]relink:impossible<toTitle>]\\\"\\n\\tvalue=\\\"EditTemplate/Title/Impossibles/Prompt\\\"\\n\\temptyValue=\\\"EditTemplate/Title/References/Prompt\\\" >\\n<$reveal type=\\\"nomatch\\\" state=<<stateTiddler>> text=\\\"show\\\">\\n<$button set=<<stateTiddler>> setTo=\\\"show\\\" class=\\\"tc-btn-invisible\\\">{{$:/core/images/right-arrow}}\\n<$macrocall $name=lingo title=<<prompt>> />\\n</$button>\\n</$reveal>\\n<$reveal type=\\\"match\\\" state=<<stateTiddler>> text=\\\"show\\\">\\n<$button set=<<stateTiddler>> setTo=\\\"hide\\\" class=\\\"tc-btn-invisible\\\">{{$:/core/images/down-arrow}}\\n<$macrocall $name=lingo title=<<prompt>> />\\n</$button>\\n</$reveal>\\n</$set>\\n\\n<$reveal type=\\\"match\\\" state=<<stateTiddler>> text=\\\"show\\\">\\n<$list variable=\\\"listItem\\\" filter=\\\"[all[relinkable]!title[$:/StoryList]relink:references<fromTitle>sort[title]]\\\" template=\\\"$:/plugins/flibbles/relink/ui/ListItemTemplate\\\">\\n</$list>\\n</$reveal>\\n</$tiddler>\\n\\n</$vars>\\n\\n</$list>\\n\\n</$vars>\\n\\n</$list>\\n\\n</$reveal>\\n\"\n        },\n        \"$:/config/flibbles/relink/PluginLibrary\": {\n            \"title\": \"$:/config/flibbles/relink/PluginLibrary\",\n            \"caption\": \"{{$:/plugins/flibbles/relink/language/PluginLibrary}}\",\n            \"url\": \"https://flibbles.github.io/tw5-relink/library/index.html\",\n            \"tags\": \"$:/tags/PluginLibrary\",\n            \"text\": \"{{$:/plugins/flibbles/relink/language/PluginLibrary/Hint}}\\n\"\n        },\n        \"$:/plugins/flibbles/relink/readme\": {\n            \"title\": \"$:/plugins/flibbles/relink/readme\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"When renaming a tiddler, Relink can update the fields, filters, and widgets\\nof all other tiddlers. However, it works through whitelisting.\\n\\nIt's already configured to update tiddler titles for all core widgets, filters,\\nand fields, but the whitelists can be customized for each of this in the\\nconfiguration panel.\\n\\nSee <a href={{$:/plugins/flibbles/relink!!source}}>the tw5-relink website</a> for more details and examples.\\n\"\n        },\n        \"$:/config/flibbles/relink/settings/default-type\": {\n            \"title\": \"$:/config/flibbles/relink/settings/default-type\",\n            \"text\": \"title\"\n        },\n        \"$:/plugins/flibbles/relink/ui/ListItemTemplate\": {\n            \"title\": \"$:/plugins/flibbles/relink/ui/ListItemTemplate\",\n            \"text\": \"<$set\\n\\tname=\\\"classes\\\"\\n\\tfilter=\\\"[<listItem>relink:impossible<toTitle>]\\\"\\n\\tvalue=\\\"tc-menu-list-item tc-relink-impossible\\\"\\n\\temptyValue=\\\"tc-menu-list-item\\\">\\n<div class=<<classes>>>\\n<$link to=<<listItem>>><$text text=<<listItem>> /></$link>\\n</div>\\n</$set>\\n\"\n        },\n        \"$:/plugins/flibbles/relink/ui/TiddlerInfo/References\": {\n            \"title\": \"$:/plugins/flibbles/relink/ui/TiddlerInfo/References\",\n            \"caption\": \"{{$:/plugins/flibbles/relink/language/TiddlerInfo/References/Caption}}\",\n            \"tags\": \"$:/tags/TiddlerInfo\",\n            \"text\": \"\\\\define lingo-base() $:/plugins/flibbles/relink/language/TiddlerInfo/\\n\\\\define filter() [relink:references<currentTiddler>!title[$:/StoryList]!prefix[$:/temp/]sort[title]]\\n<$list filter=\\\"[subfilter<filter>first[]]\\\">\\n\\n<<lingo References/Description>>\\n</$list>\\n\\n<table class=\\\"tc-relink-references-table\\\">\\n<tbody>\\n<$list filter=<<filter>> emptyMessage=<<lingo References/Empty>> variable=\\\"listItem\\\" template=\\\"$:/plugins/flibbles/relink/ui/TiddlerInfo/ReferencesTemplate\\\" />\\n</tbody>\\n</table>\\n\"\n        },\n        \"$:/plugins/flibbles/relink/ui/TiddlerInfo/ReferencesTemplate\": {\n            \"title\": \"$:/plugins/flibbles/relink/ui/TiddlerInfo/ReferencesTemplate\",\n            \"text\": \"<tr class=\\\"tc-relink-references\\\">\\n<td class=\\\"tc-relink-references-title\\\">\\n<$link to=<<listItem>>/>\\n</td>\\n<td class=\\\"tc-relink-references-report\\\">\\n<$list filter=\\\"[<listItem>relink:report<currentTiddler>]\\\">\\n\\n<$text text=<<currentTiddler>> />\\n</$list>\\n\\n</td>\\n</tr>\\n\"\n        },\n        \"$:/plugins/flibbles/relink/ui/components/button-delete\": {\n            \"title\": \"$:/plugins/flibbles/relink/ui/components/button-delete\",\n            \"text\": \"\\\\define lingo-base() $:/plugins/flibbles/relink/language/Buttons/\\n\\\\define prefix() $:/config/flibbles/relink/\\n\\n<$list filter=\\\"[all[current]prefix<prefix>]\\\" >\\n<$button class=\\\"tc-btn-invisible\\\" tooltip={{$:/plugins/flibbles/relink/language/Buttons/Delete/Hint}}><$list filter=\\\"[all[current]is[tiddler]]\\\">\\n<$action-deletetiddler $tiddler=<<currentTiddler>> />\\n</$list><$list filter=\\\"[all[current]is[shadow]]\\\">\\n<$action-setfield $tiddler=<<tiddlerName>> text=\\\"\\\" />\\n</$list>\\n{{$:/core/images/delete-button}}\\n</$button>\\n</$list><$list filter=\\\"[all[current]!prefix<prefix>]\\\">\\n<$link><$button class=\\\"tc-btn-invisible\\\" tooltip={{$:/plugins/flibbles/relink/language/Buttons/LinkToInline/Hint}}>{{$:/core/images/link}}</$button></$link>\\n</$list>\\n\"\n        },\n        \"$:/plugins/flibbles/relink/ui/components/select-fieldtype\": {\n            \"title\": \"$:/plugins/flibbles/relink/ui/components/select-fieldtype\",\n            \"text\": \"\\\\define prefix() $:/config/flibbles/relink/\\n\\n<$vars type={{{ [<signature>relink:type[]] }}} >\\n<$list filter=\\\"[all[current]prefix<prefix>]\\\" >\\n<$select tiddler=<<currentTiddler>> >\\n<$list variable=\\\"option\\\" filter=\\\"[relink:types[]]\\\">\\n<option><$text text=<<option>> /></option>\\n</$list>\\n</$select>\\n</$list><$list filter=\\\"[all[current]!prefix<prefix>]\\\">\\n<$text text=<<type>> />\\n</$list>\\n</$vars>\\n\"\n        },\n        \"$:/plugins/flibbles/relink/ui/components/tables\": {\n            \"title\": \"$:/plugins/flibbles/relink/ui/components/tables\",\n            \"text\": \"\\\\define .make-table(title, plugin, default-table-state:yes)\\n\\n<$list variable=\\\"render\\\" filter=\\\"[relink:signatures<__plugin__>prefix<__category__>first[]]\\\">\\n<$set name=\\\"table-state\\\" value=<<qualify \\\"\\\"\\\"$:/state/flibbles/relink/tables/$title$\\\"\\\"\\\">>>\\n<tr><th class=\\\"tc-relink-header-plugin\\\" colspan=<<column-count>> >\\n<$reveal type=\\\"nomatch\\\" state=<<table-state>> text=\\\"yes\\\" default=\\\"\\\"\\\"$default-table-state$\\\"\\\"\\\">\\n<$button class=\\\"tc-btn-invisible tc-btn-dropdown\\\" set=<<table-state>> setTo=\\\"yes\\\">\\n{{$:/core/images/right-arrow}} ''$title$''\\n</$button>\\n</$reveal>\\n<$reveal type=\\\"match\\\" state=<<table-state>> text=\\\"yes\\\" default=\\\"\\\"\\\"$default-table-state$\\\"\\\"\\\">\\n<$button class=\\\"tc-btn-invisible tc-btn-dropdown\\\" set=<<table-state>> setTo=\\\"no\\\">\\n{{$:/core/images/down-arrow}} ''$title$''\\n</$button>\\n</$reveal>\\n</th></tr>\\n<$list\\n\\tvariable=\\\"signature\\\"\\n\\tfilter=\\\"[relink:signatures<__plugin__>prefix<__category__>sort[]]\\\">\\n<$vars key={{{ [<signature>removeprefix<__category__>removeprefix[/]] }}} >\\n<$tiddler tiddler={{{[<signature>relink:source[]]}}} >\\n<$reveal tag=\\\"tr\\\" type=\\\"match\\\" state=<<table-state>> text=\\\"yes\\\" default=\\\"\\\"\\\"$default-table-state$\\\"\\\"\\\">\\n<$macrocall $name=<<__list-row-macro__>> signature=<<signature>> />\\n<td class=\\\"tc-relink-column-type\\\">{{||$:/plugins/flibbles/relink/ui/components/select-fieldtype}}</td>\\n<td class=\\\"tc-relink-column-delete\\\">{{||$:/plugins/flibbles/relink/ui/components/button-delete}}</td>\\n</$reveal>\\n</$tiddler>\\n</$vars>\\n</$list>\\n</$set>\\n</$list>\\n\\\\end\\n\\n\\\\define tables(category, list-row-macro, header-list)\\n<$vars\\n\\tcolumn-count={{{[enlist<__header-list__>] [[DeleteColumn]] +[count[]]}}}>\\n\\n<table class=\\\"tc-relink-whitelist\\\"><tbody>\\n<tr>\\n<$list variable=\\\"header\\\" filter=\\\"[enlist<__header-list__>butlast[]]\\\"><th><<header>></th></$list>\\n<!-- We have the last column extend into the delete/link column, which is unlabeled. -->\\n<th colspan=2><$text text={{{ [enlist<__header-list__>last[]] }}} /></th>\\n</tr>\\n\\n<<.make-table Custom \\\"\\\" yes>>\\n\\n<$list\\n\\tfilter=\\\"[plugin-type[plugin]![$:/core]![$:/plugins/flibbles/relink]]\\\">\\n<$set name=\\\"subtitle\\\" value={{!!description}} emptyValue={{!!title}} >\\n<$macrocall $name=\\\".make-table\\\" title=<<subtitle>> plugin=<<currentTiddler>> />\\n</$set>\\n</$list>\\n\\n<<.make-table Core \\\"$:/plugins/flibbles/relink\\\">>\\n\\n</tbody></table>\\n</$vars>\\n\\\\end\\n\"\n        },\n        \"$:/plugins/flibbles/relink/ui/configuration/Attributes\": {\n            \"title\": \"$:/plugins/flibbles/relink/ui/configuration/Attributes\",\n            \"caption\": \"{{$:/plugins/flibbles/relink/language/ui/Attributes/Caption}}\",\n            \"tags\": \"$:/tags/flibbles/relink/Configuration\",\n            \"text\": \"\\\\import $:/plugins/flibbles/relink/ui/components/tables\\n\\\\define prefix-attr() $:/config/flibbles/relink/attributes/\\n\\\\define lingo-base() $:/plugins/flibbles/relink/language/Buttons/\\n\\\\define element-name-tiddler() $:/state/flibbles/relink/element-name\\n\\\\define attribute-name-tiddler() $:/state/flibbles/relink/attribute-name\\n\\n\\\\define row()\\n<$set name=\\\"element\\\"\\n      filter=\\\"[<key>splitbefore[/]removesuffix[/]]\\\">\\n<$set name=\\\"attribute\\\"\\n      filter=\\\"[<key>removeprefix<element>removeprefix[/]]\\\">\\n<td><$text text=<<element>> /></td>\\n<td><$text text=<<attribute>> /></td>\\n</$set></$set>\\n\\\\end\\n\\\\define body()\\n\\n{{$:/plugins/flibbles/relink/language/Help/Attributes}}\\n\\n<em class=\\\"tc-edit\\\">Add a new attribute:</em>\\n<$edit-text\\n\\ttiddler=<<element-name-tiddler>>\\n\\ttag=\\\"input\\\"\\n\\tdefault=\\\"\\\"\\n\\tplaceholder=\\\"widget/element\\\" />\\n<$edit-text\\n\\ttiddler=<<attribute-name-tiddler>>\\n\\ttag=\\\"input\\\"\\n\\tdefault=\\\"\\\"\\n\\tplaceholder=\\\"attribute\\\" />\\n<$reveal type=\\\"nomatch\\\" text=\\\"\\\" state=<<element-name-tiddler>> >\\n<$reveal type=\\\"nomatch\\\" text=\\\"\\\" state=<<attribute-name-tiddler>> >\\n<$relinkmangler>\\n<$button\\n\\ttooltip={{$(lingo-base)$NewAttribute/Hint}}\\n\\taria-label={{$(lingo-base)$NewAttribute/Caption}}>\\n<$action-sendmessage\\n\\t$message=\\\"relink-add-attribute\\\"\\n\\telement={{$(element-name-tiddler)$}}\\n\\tattribute={{$(attribute-name-tiddler)$}} />\\n<$action-deletetiddler $tiddler=<<attribute-name-tiddler>> />\\n<$action-deletetiddler $tiddler=<<element-name-tiddler>> />\\n<$text text={{$(lingo-base)$NewAttribute/Caption}}/>\\n</$button>\\n</$relinkmangler>\\n</$reveal>\\n<$reveal type=\\\"match\\\" text=\\\"\\\" state=<<attribute-name-tiddler>> >\\n<$button>\\n<$text text={{$(lingo-base)$NewAttribute/Caption}}/>\\n</$button>\\n</$reveal>\\n</$reveal>\\n<$reveal type=\\\"match\\\" text=\\\"\\\" state=<<element-name-tiddler>> >\\n<$button>\\n<$text text={{$(lingo-base)$NewAttribute/Caption}}/>\\n</$button>\\n</$reveal>\\n\\n<$macrocall\\n\\t$name=tables\\n\\tcategory=\\\"attributes\\\"\\n\\theader-list=\\\"[[Widget/HTML Element]] Attribute Type\\\"\\n\\tlist-row-macro=\\\"row\\\" />\\n\\\\end\\n\\n<<body>>\\n\"\n        },\n        \"$:/plugins/flibbles/relink/ui/configuration/Fields\": {\n            \"title\": \"$:/plugins/flibbles/relink/ui/configuration/Fields\",\n            \"caption\": \"{{$:/plugins/flibbles/relink/language/ui/Fields/Caption}}\",\n            \"tags\": \"$:/tags/flibbles/relink/Configuration\",\n            \"text\": \"\\\\import $:/plugins/flibbles/relink/ui/components/tables\\n\\\\define lingo-base() $:/plugins/flibbles/relink/language/Buttons/\\n\\\\define field-name-tiddler() $:/state/flibbles/relink/field-name\\n\\n\\\\define row()\\n<td><$text text=<<key>> /></td>\\n\\\\end\\n\\\\define body()\\n\\n{{$:/plugins/flibbles/relink/language/Help/Fields}}\\n\\n<em class=\\\"tc-edit\\\">Add a new field:</em>\\n<$edit-text\\n\\ttiddler=<<field-name-tiddler>>\\n\\ttag=\\\"input\\\"\\n\\tdefault=\\\"\\\"\\n\\tplaceholder=\\\"field name\\\" />\\n<$reveal type=\\\"nomatch\\\" text=\\\"\\\" state=<<field-name-tiddler>> >\\n<$relinkmangler>\\n<$button\\n\\ttooltip={{$(lingo-base)$NewField/Hint}}\\n\\taria-label={{$(lingo-base)$NewField/Caption}}>\\n<$action-sendmessage\\n\\t$message=\\\"relink-add-field\\\"\\n\\tfield={{$(field-name-tiddler)$}} />\\n<$action-deletetiddler $tiddler=<<field-name-tiddler>> />\\n<$text text={{$(lingo-base)$NewField/Caption}}/>\\n</$button>\\n</$relinkmangler>\\n</$reveal>\\n<$reveal type=\\\"match\\\" text=\\\"\\\" state=<<field-name-tiddler>> >\\n<$button>\\n<$text text={{$(lingo-base)$NewField/Caption}}/>\\n</$button>\\n</$reveal>\\n\\n\\n<$macrocall\\n\\t$name=tables\\n\\tcategory=\\\"fields\\\"\\n\\theader-list=\\\"[[Field Name]] [[Field Type]]\\\"\\n\\tlist-row-macro=\\\"row\\\" />\\n\\\\end\\n\\n<<body>>\\n\"\n        },\n        \"$:/plugins/flibbles/relink/ui/configuration/Macros\": {\n            \"title\": \"$:/plugins/flibbles/relink/ui/configuration/Macros\",\n            \"caption\": \"{{$:/plugins/flibbles/relink/language/ui/Macros/Caption}}\",\n            \"tags\": \"$:/tags/flibbles/relink/Configuration\",\n            \"text\": \"\\\\import $:/plugins/flibbles/relink/ui/components/tables\\n\\\\define prefix-macro() $:/config/flibbles/relink/macros/\\n\\\\define lingo-base() $:/plugins/flibbles/relink/language/Buttons/\\n\\\\define macro-name-tiddler() $:/state/flibbles/relink/macro-name\\n\\\\define parameter-name-tiddler() $:/state/flibbles/relink/parameter-name\\n\\n\\\\define row()\\n<$set name=\\\"parameter\\\"\\n      filter=\\\"[<key>relink:splitafter[/]]\\\">\\n<$set name=\\\"macro\\\"\\n      filter=\\\"[<key>removesuffix<parameter>removesuffix[/]]\\\">\\n<td><$text text=<<macro>> /></td>\\n<td><$text text=<<parameter>> /></td>\\n</$set></$set>\\n\\\\end\\n\\\\define body()\\n\\n{{$:/plugins/flibbles/relink/language/Help/Macros}}\\n\\n<em class=\\\"tc-edit\\\">Add a new macro parameter:</em>\\n<$edit-text\\n\\ttiddler=<<macro-name-tiddler>>\\n\\ttag=\\\"input\\\"\\n\\tdefault=\\\"\\\"\\n\\tplaceholder=\\\"macro\\\" />\\n<$edit-text\\n\\ttiddler=<<parameter-name-tiddler>>\\n\\ttag=\\\"input\\\"\\n\\tdefault=\\\"\\\"\\n\\tplaceholder=\\\"parameter\\\" />\\n<$reveal type=\\\"nomatch\\\" text=\\\"\\\" state=<<macro-name-tiddler>> >\\n<$reveal type=\\\"nomatch\\\" text=\\\"\\\" state=<<parameter-name-tiddler>> >\\n<$relinkmangler>\\n<$button\\n\\ttooltip={{$(lingo-base)$NewParameter/Hint}}\\n\\taria-label={{$(lingo-base)$NewParameter/Caption}}>\\n<$action-sendmessage\\n\\t$message=\\\"relink-add-parameter\\\"\\n\\tmacro={{$(macro-name-tiddler)$}}\\n\\tparameter={{$(parameter-name-tiddler)$}} />\\n<$action-deletetiddler $tiddler=<<parameter-name-tiddler>> />\\n<$action-deletetiddler $tiddler=<<macro-name-tiddler>> />\\n<$text text={{$(lingo-base)$NewParameter/Caption}}/>\\n</$button>\\n</$relinkmangler>\\n</$reveal>\\n<$reveal type=\\\"match\\\" text=\\\"\\\" state=<<parameter-name-tiddler>> >\\n<$button>\\n<$text text={{$(lingo-base)$NewParameter/Caption}}/>\\n</$button>\\n</$reveal>\\n</$reveal>\\n<$reveal type=\\\"match\\\" text=\\\"\\\" state=<<macro-name-tiddler>> >\\n<$button>\\n<$text text={{$(lingo-base)$NewParameter/Caption}}/>\\n</$button>\\n</$reveal>\\n\\n\\n<$macrocall\\n\\t$name=tables\\n\\tcategory=\\\"macros\\\"\\n\\theader-list=\\\"Macro Parameter Type\\\"\\n\\tlist-row-macro=\\\"row\\\" />\\n\\\\end\\n\\n<<body>>\\n\"\n        },\n        \"$:/plugins/flibbles/relink/ui/configuration/Operators\": {\n            \"title\": \"$:/plugins/flibbles/relink/ui/configuration/Operators\",\n            \"caption\": \"{{$:/plugins/flibbles/relink/language/ui/Operators/Caption}}\",\n            \"tags\": \"$:/tags/flibbles/relink/Configuration\",\n            \"text\": \"\\\\import $:/plugins/flibbles/relink/ui/components/tables\\n\\\\define lingo-base() $:/plugins/flibbles/relink/language/Buttons/\\n\\\\define operator-name-tiddler() $:/state/flibbles/relink/operator-name\\n\\n\\\\define row()\\n<td><$text text=<<key>> /></td>\\n\\\\end\\n\\\\define body()\\n\\n{{$:/plugins/flibbles/relink/language/Help/Operators}}\\n\\n<em class=\\\"tc-edit\\\">Add a new filter operator:</em>\\n<$edit-text\\n\\ttiddler=<<operator-name-tiddler>>\\n\\ttag=\\\"input\\\"\\n\\tdefault=\\\"\\\"\\n\\tplaceholder=\\\"operator name\\\" />\\n<$reveal type=\\\"nomatch\\\" text=\\\"\\\" state=<<operator-name-tiddler>>>\\n<$relinkmangler>\\n<$button\\n\\ttooltip={{$(lingo-base)$NewOperator/Hint}}\\n\\taria-label={{$(lingo-base)$NewOperator/Caption}}>\\n<$action-sendmessage\\n\\t$message=\\\"relink-add-operator\\\"\\n\\toperator={{$(operator-name-tiddler)$}} />\\n<$action-deletetiddler $tiddler=<<operator-name-tiddler>> />\\n<$text text={{$(lingo-base)$NewOperator/Caption}}/>\\n</$button>\\n</$relinkmangler>\\n</$reveal>\\n<$reveal type=\\\"match\\\" text=\\\"\\\" state=<<operator-name-tiddler>>>\\n<$button>\\n<$text text={{$(lingo-base)$NewOperator/Caption}}/>\\n</$button>\\n</$reveal>\\n\\n<$macrocall\\n\\t$name=tables\\n\\tcategory=\\\"operators\\\"\\n\\theader-list=\\\"[[Filter Operator]] [[Operand Type]]\\\"\\n\\tlist-row-macro=\\\"row\\\" />\\n\\\\end\\n\\n<<body>>\\n\"\n        },\n        \"$:/plugins/flibbles/relink/ui/stylesheet.css\": {\n            \"title\": \"$:/plugins/flibbles/relink/ui/stylesheet.css\",\n            \"text\": \".tc-relink-references {\\n}\\n\\n.tc-relink-references-table {\\n\\twidth: 100%;\\n\\tborder: none;\\n}\\n\\n.tc-relink-references-table td {\\n\\tborder-left: none;\\n}\\n\\n.tc-relink-references-table tr:first-child td {\\n\\tborder-top: none;\\n}\\n\\n.tc-relink-references-title {\\n\\ttext-align: left;\\n\\tvertical-align: top;\\n}\\n\\n.tc-relink-references-occurrence {\\n\\tfont-style: italic;\\n\\ttext-align: left;\\n\\tfont-weight: 200;\\n\\tpadding-left: 25px;\\n\\tvertical-align: top;\\n}\\n\\n.tc-relink-header-plugin {\\n\\ttext-align: left;\\n}\\n\\n.tc-relink-header-plugin button {\\n\\twidth: 100%\\n}\\n\\n.tc-relink-column-type {\\n\\twidth: 8em;\\n}\\n\\n.tc-relink-column-type select {\\n\\twidth: 100%;\\n}\\n\\n.tc-relink-column-delete {\\n\\tborder-left: none;\\n\\ttext-align: left;\\n}\\n\\n.tc-relink-column-delete button {\\n\\tpadding-left: 1em;\\n}\\n\\n.tc-relink-impossible a.tc-tiddlylink {\\n\\tcolor: red;\\n}\\n\",\n            \"tags\": \"$:/tags/Stylesheet\",\n            \"type\": \"text/css\"\n        }\n    }\n}"}